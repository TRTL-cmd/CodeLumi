<!doctype html>
<!-- Copyright (c) 2026 Tortol studios. All rights reserved. Contact: Tortolcoin@gmail.com -->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' https:; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://unpkg.com; style-src 'self' 'unsafe-inline' https:; connect-src 'self' https: blob: data:; img-src 'self' data: blob:;">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lumi Desktop</title>
  <style>
    :root{--bg:#0b1220;--card:#0f1724;--accent:#ff7ab6;--muted:#9aa4b2}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#071029 0%,#0b1220 100%);font-family:Inter,Segoe UI,Arial;color:#e6eef8}
    #lumi{position:fixed;right:20px;top:50%;transform:translateY(-50%);width:340px;z-index:10000;cursor:grab}
    .avatar{background:linear-gradient(180deg,#101827,#08101a);border-radius:12px;padding:12px;box-shadow:0 12px 40px rgba(0,0,0,.6);display:flex;gap:12px;align-items:flex-start}
    /* hide legacy SVG avatar (pink square) to prefer the main 3D model */
    .svg-face{display:none;width:84px;height:84px;flex:0 0 84px}
    .body{flex:1}
    .name{font-weight:700;font-size:1.05rem}
    .tone{color:var(--muted);font-size:.86rem;margin-top:4px}
    .controls{margin-top:10px;display:flex;gap:8px}
    .qa{margin-top:12px;display:flex;gap:8px;align-items:flex-end}
    .qa input,.qa textarea{flex:1;padding:8px;border-radius:8px;border:1px solid #24303a;background:#07101a;color:#e6eef8;font-family:Inter,Segoe UI,Arial}
    .qa textarea{min-height:40px;max-height:240px;resize:none;overflow:auto;line-height:1.25;padding-top:8px;padding-bottom:8px}
.bubble{position:fixed;left:24%;top:45%;transform:translate(-50%, -50%);max-width:300px;background:#ffffff;color:#0b1220;padding:12px 14px;border-radius:12px;box-shadow:0 8px 20px rgba(2,6,23,.25);white-space:pre-wrap;display:none;box-sizing:border-box;font-size:13px;line-height:1.4;overflow:auto;max-height:220px;z-index:10060;pointer-events:auto}    #codePanel{display:none}
    .code-area{width:100%;height:220px;margin-top:10px;background:#07101a;color:#e6eef8;padding:10px;border-radius:8px;border:1px solid #24303a;font-family:Consolas,monospace;white-space:pre-wrap;overflow:auto}
    .analysis{margin-top:8px;background:#07101a;padding:8px;border-radius:8px;border:1px solid #24303a;color:#e6eef8;max-height:260px;overflow:auto;white-space:pre-wrap}
    dialog{border-radius:8px;padding:12px;border:1px solid #24303a;background:#0b1220;color:#e6eef8}
    .tiny{background:#1f2b36;padding:6px 8px;border-radius:8px;border:none;color:#e6eef8;cursor:pointer}
    button{background:var(--accent);border:none;color:#fff;padding:6px 10px;border-radius:8px;cursor:pointer}
  </style>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
</head>
<body>
  <div id="lumi" title="Drag me">
    <div class="avatar" id="avatarRoot">
      <svg class="svg-face" viewBox="0 0 120 120" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Lumi avatar">
        <!-- stylized anime-like face (simple, non-photoreal) -->
        <defs>
          <linearGradient id="hair" x1="0" x2="0" y1="0" y2="1"><stop offset="0" stop-color="#ff9ccf"/><stop offset="1" stop-color="#ff6aa6"/></linearGradient>
        </defs>
        <rect width="120" height="120" rx="16" fill="url(#hair)"/>
        <circle cx="36" cy="54" r="8" fill="#fff"/>
        <circle cx="84" cy="54" r="8" fill="#fff"/>
        <path d="M38 76 Q60 90 82 76" stroke="#fff" stroke-width="3" fill="none" stroke-linecap="round"/>
        <!-- blush -->
        <ellipse cx="28" cy="68" rx="6" ry="3" fill="rgba(255,255,255,0.18)"/>
        <ellipse cx="92" cy="68" rx="6" ry="3" fill="rgba(255,255,255,0.18)"/>
      </svg>

      <div class="body">
        <div class="name" id="lumiName">Lumi</div>
        <div class="tone" id="lumiTone">playful · curious · helpful</div>

        <div class="controls">
          <button id="speakBtn">Say Hi</button>
          <button id="openSettings" class="tiny">Settings</button>
          <button id="openCurator" class="tiny">Security Curator</button>
          <button id="selflearnToggle" class="tiny">Self‑Learn: Off</button>
        </div>

        <div class="qa">
          <textarea id="question" placeholder="Ask Lumi about code or paste a snippet..." rows="1"></textarea>
          <button id="ask">Ask</button>
        </div>

        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="openCode" class="tiny">Open Code Editor</button>
          <button id="downloadKB" class="tiny">Download KB</button>
        </div>

        <div style="font-size:.9rem;color:var(--muted);margin-top:8px" id="score">Knowledge entries: 0</div>
        <div id="metricsPanel" style="margin-top:6px;font-size:0.85rem;color:var(--muted);display:flex;gap:10px;align-items:center">
          <div><strong style="color:#e6eef8">Total KB:</strong> <span id="metricsTotal">0</span></div>
          <div><strong style="color:#e6eef8">Events Today:</strong> <span id="metricsEvents">0</span></div>
          <div><strong style="color:#e6eef8">Events/hr:</strong> <span id="metricsRate">0</span></div>
        </div>
      </div>
    </div>
  </div>
  
      <!-- Combined Settings Panel: General, Personality, History, Memory -->
      <div id="settingsPanel" style="position:fixed;right:24px;bottom:24px;width:520px;max-height:80vh;overflow:auto;background:#0b1220;color:#e6eef8;padding:12px;border-radius:12px;display:none;box-shadow:0 18px 60px rgba(2,6,23,.6);z-index:10002">
        <div style="display:flex;justify-content:space-between;align-items:center"><strong>Settings</strong><div><button id="closeSettings" class="tiny">Close</button></div></div>

        <div style="display:flex;gap:8px;margin-top:8px">
          <button id="settingsTabGeneral" class="tiny">General</button>
          <button id="settingsTabPersonality" class="tiny">Personality</button>
          <button id="settingsTabHistory" class="tiny">History</button>
          <button id="settingsTabMemory" class="tiny">Memory</button>
        </div>

        <div id="settings_tab_general" style="margin-top:10px">
          <label style="margin-top:8px;color:var(--muted)">3D Model (GLB filename from assets/models/)</label>
          <div style="display:flex;gap:8px">
            <input id="modelFilename" placeholder="default.glb" style="flex:1" />
            <button id="loadModelBtn" class="tiny">Load Model</button>
          </div>
          <p style="color:var(--muted);font-size:.8rem;margin-top:4px">Place your .glb file in the assets/models/ folder and enter the filename. The app will attempt to load it immediately.</p>

          <div style="margin-top:10px;border-top:1px solid #172029;padding-top:10px">
            <div style="display:flex;flex-direction:column;gap:8px">
              <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="lumiFeedbackToggle" /> <span style="color:var(--muted);font-size:.9rem">Enable Feedback UI</span></label>
              <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="codelumiAutoTrainToggle" /> <span style="color:var(--muted);font-size:.9rem">Enable Auto‑Train</span></label>
              <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="codelumiSpinOnOpen" /> <span style="color:var(--muted);font-size:.9rem">Spin model on open</span></label>
            </div>
          </div>

          <div id="animationsSection" style="margin-top:12px;border-top:1px solid #172029;padding-top:10px;display:none">
            <div style="display:flex;justify-content:space-between;align-items:center">
              <strong>Animation Controls</strong>
              <div style="font-size:.82rem;color:var(--muted)">Model &amp; procedural</div>
            </div>
            <div style="display:flex;gap:8px;margin-top:8px">
              <button id="lumiAnimIdle" class="tiny">Idle</button>
              <button id="lumiAnimWalk" class="tiny">Walk</button>
              <button id="lumiAnimWave" class="tiny">Wave</button>
              <button id="lumiAnimSpin" class="tiny">Spin</button>
              <button id="lumiAnimBounce" class="tiny">Bounce</button>
              <button id="lumiToggleRotate" class="tiny">Stop Rotate</button>
            </div>
          </div>

          <div style="margin-top:12px;border-top:1px solid #172029;padding-top:10px">
            <strong>Self‑Learn Folders</strong>
            <div style="color:var(--muted);font-size:.82rem;margin-top:4px">Pick folders Lumi can read for self‑learn. These are local-only and not uploaded.</div>
            <div id="selflearnFolderList" style="margin-top:8px;display:flex;flex-direction:column;gap:6px"></div>
            <div style="display:flex;gap:8px;margin-top:8px">
              <button id="selflearnFolderAdd" class="tiny">Browse…</button>
              <button id="selflearnFolderSave" class="tiny">Save Folders</button>
            </div>
          </div>
        </div>

        <div id="settings_tab_personality" style="display:none;margin-top:10px">
          <label style="margin-top:8px;color:var(--muted)">Display name</label>
          <input id="personaName" placeholder="Lumi" />

          <label style="margin-top:8px;color:var(--muted)">Tone / Short descriptor</label>
          <input id="personaTone" placeholder="(Lumi chooses her tone)" readonly disabled title="Lumi controls her tone" />

          <label style="margin-top:8px;color:var(--muted)">Interests (comma separated)</label>
          <input id="personaInterests" placeholder="coding, cats, turtles, learning" />

          <div style="display:flex;gap:8px;margin-top:10px">
            <button id="savePersona">Save Persona</button>
            <button id="resetPersona" class="tiny">Reset</button>
          </div>

          <div id="personaHistoryPanel" style="margin-top:12px;border-top:1px solid #172029;padding-top:10px">
            <strong>Persona History</strong>
            <div id="personaHistoryList" style="margin-top:8px;max-height:220px;overflow:auto;padding:8px;border-radius:8px;border:1px solid #172029;background:#06101a;color:#e6eef8"></div>
            <div style="display:flex;gap:8px;margin-top:8px"><button id="personaHistoryClose" class="tiny">Close</button><button id="personaHistoryClear" class="tiny">Clear History</button></div>
          </div>
        </div>

        <div id="settings_tab_history" style="display:none;margin-top:10px">
          <div style="display:flex;justify-content:space-between;align-items:center"><strong>Conversation History</strong></div>
          <div id="historyList" style="max-height:360px;overflow:auto;margin-top:8px;background:#07101a;padding:8px;border-radius:8px;border:1px solid #24303a;color:#e6eef8;font-size:0.9rem"></div>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="exportHistory">Export JSON</button>
            <button id="clearHistory" class="tiny">Clear</button>
          </div>
        </div>

        <div id="settings_tab_memory" style="display:none;margin-top:10px">
          <div style="display:flex;justify-content:space-between;align-items:center"><strong>Memory Viewer</strong><div><button id="personaMemoryClose" class="tiny">Close</button></div></div>
          <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
            <input id="memorySearch" placeholder="Search memory (keyword)" style="flex:1;padding:8px;border-radius:8px;border:1px solid #24303a;background:#06101a;color:#e6eef8" />
            <button id="memorySearchBtn" class="tiny">Search</button>
            <button id="memoryRefreshBtn" class="tiny">Refresh</button>
            <button id="memoryExportBtn" class="tiny">Export</button>
          </div>
          <div id="memoryList" style="margin-top:10px;max-height:320px;overflow:auto;padding:8px;border-radius:8px;border:1px solid #172029;background:#0b1220"></div>
        </div>
      </div>

      <!-- Security Curator Panel -->
      <div id="curatorPanel" style="position:fixed;left:24px;bottom:24px;width:520px;height:520px;background:#07101a;color:#e6eef8;padding:12px;border-radius:12px;display:none;box-shadow:0 18px 60px rgba(2,6,23,.6);z-index:10004;overflow:auto">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <strong>Security Curator</strong>
          <div><button id="closeCurator" class="tiny">Close</button></div>
        </div>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <button id="curatorRefresh" class="tiny">Refresh</button>
          <button id="curatorArchives" class="tiny">Archives</button>
          <button id="curatorSuggestions" class="tiny">Suggestions</button>
          <span id="curatorStatus" style="color:var(--muted);margin-left:8px">Loading…</span>
        </div>
        <div id="curatorList" style="margin-top:12px;max-height:420px;overflow:auto;padding:8px;border-radius:8px;border:1px solid #172029;background:#0b1220"></div>
      </div>

  <div class="bubble" id="bubble" role="status"></div>

  

  <div id="codePanel" style="position:fixed;left:24px;bottom:24px;width:720px;display:none;z-index:9999">
    <div style="background:linear-gradient(180deg,#0b1220,#06101a);padding:10px;border-radius:12px;border:1px solid #24303a;box-shadow:0 18px 60px rgba(2,6,23,.6);color:#e6eef8">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>Code Editor & Analyzer</strong> <span id="codeLangBadge" style="margin-left:8px;font-size:12px;color:var(--muted)"></span></div>
        <div><button id="closeCode" class="tiny">Close</button></div>
      </div>
      <textarea id="codeInput" class="code-area" placeholder="// Paste code here (JS/Python/C/C++)"></textarea>
      <div id="reactEditorMount" style="display:none;margin-top:8px"></div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="analyze">Analyze & Fix</button>
        <button id="format" class="tiny">Format</button>
        <button id="applyFix" class="tiny">Apply Fix</button>
        <button id="downloadCode" class="tiny">Download</button>
        <button id="saveSnapshot" class="tiny">Save Snapshot</button>
        <button id="openSnapshots" class="tiny">Snapshots</button>
      </div>
      <div class="analysis" id="analysisArea">Analysis output will appear here.</div>
      <div id="snapshotPanel" style="display:none;margin-top:8px;background:#06121a;padding:8px;border-radius:8px;border:1px solid #172029;color:#e6eef8">
        <div style="display:flex;justify-content:space-between;align-items:center"><strong>Snapshots</strong><div><button id="closeSnapshots" class="tiny">Close</button></div></div>
        <div id="snapshotList" style="margin-top:8px;max-height:180px;overflow:auto;padding:6px;border-radius:6px;background:#07101a;border:1px solid #24303a"></div>
        <div style="display:flex;gap:8px;margin-top:8px"><button id="saveSnapshotQuick" class="tiny">Save Quick</button><button id="downloadSnapshots" class="tiny">Export</button></div>
      </div>
    </div>
  </div>

  <dialog id="modalPrompt">
    <form method="dialog" style="display:flex;flex-direction:column;gap:8px">
      <div id="modalQuestion"></div>
      <input id="modalInput" />
      <menu style="display:flex;gap:8px;justify-content:flex-end">
        <button id="modalCancel" value="cancel">Cancel</button>
        <button id="modalOk" value="ok">OK</button>
      </menu>
    </form>
  </dialog>

  <script>
  document.addEventListener('DOMContentLoaded', function(){
    // Dynamic loader for compiled React island: SecurityCurator
    (function ensureSecurityCuratorLoaded() {
      // If the React mount point exists but the compiled component isn't on window,
      // dynamically load the compiled bundle and mount when ready.
      const mountEl = document.querySelector('#curatorReactMount');
      if (!mountEl) return;

      function tryMount() {
        try {
          if (window.SecurityCurator && typeof window.SecurityCurator === 'function') {
            // mount the React component into the mount element
            const React = window.React || (window.require && window.require('react'));
            const ReactDOM = window.ReactDOM || (window.require && window.require('react-dom'));
            if (React && ReactDOM) {
              const root = ReactDOM.createRoot ? ReactDOM.createRoot(mountEl) : null;
              if (root) { root.render(React.createElement(window.SecurityCurator, {})); }
              else { ReactDOM.render(React.createElement(window.SecurityCurator, {}), mountEl); }
              console.info('[SecurityCurator] Mounted after dynamic load');
              return true;
            }
          }
        } catch (e) {
          console.warn('[SecurityCurator] mount attempt failed', e);
        }
        return false;
      }

      if (tryMount()) return;

      // Poll for SecurityCurator (loaded via module script at end of page)
      const poll = setInterval(() => { if (tryMount()) clearInterval(poll); }, 250);
      setTimeout(() => clearInterval(poll), 10000); // stop polling after 10s
    })();
    /* Elements */
    const bubble = document.getElementById('bubble');
    const speakBtn = document.getElementById('speakBtn');
    const openSettings = document.getElementById('openSettings');
    const settingsPanel = document.getElementById('settingsPanel');
    const closeSettings = document.getElementById('closeSettings');
    const openPersonality = document.getElementById('openPersonality');
    const personalityPanel = document.getElementById('personalityPanel');
    const closePersonality = document.getElementById('closePersonality');
    const savePersona = document.getElementById('savePersona');
    const resetPersona = document.getElementById('resetPersona');
    const personaName = document.getElementById('personaName');
    const personaTone = document.getElementById('personaTone');
    const personaInterests = document.getElementById('personaInterests');

    const askBtn = document.getElementById('ask');
    const questionInput = document.getElementById('question');
    const scoreEl = document.getElementById('score');
    const openCode = document.getElementById('openCode');
    const codePanel = document.getElementById('codePanel');
    const closeCode = document.getElementById('closeCode');
    const codeInput = document.getElementById('codeInput');
    const analyzeBtn = document.getElementById('analyze');
    const formatBtn = document.getElementById('format');
    const applyFixBtn = document.getElementById('applyFix');
    const analysisArea = document.getElementById('analysisArea');
    const downloadKBBtn = document.getElementById('downloadKB');
    const downloadCodeBtn = document.getElementById('downloadCode');
    const openHistory = document.getElementById('openHistory');
    const historyPanel = document.getElementById('historyPanel');
    const historyList = document.getElementById('historyList');
    const closeHistory = document.getElementById('closeHistory');
    const selflearnToggle = document.getElementById('selflearnToggle');
    const exportHistoryBtn = document.getElementById('exportHistory');
    const clearHistoryBtn = document.getElementById('clearHistory');
    const codelumiAnimIdle = document.getElementById('lumiAnimIdle') || document.getElementById('codelumiAnimIdle');
    const codelumiAnimWalk = document.getElementById('lumiAnimWalk') || document.getElementById('codelumiAnimWalk');
    const codelumiAnimWave = document.getElementById('lumiAnimWave') || document.getElementById('codelumiAnimWave');
    const codelumiAnimSpin = document.getElementById('lumiAnimSpin') || document.getElementById('codelumiAnimSpin');
    const codelumiAnimBounce = document.getElementById('lumiAnimBounce') || document.getElementById('codelumiAnimBounce');
    const codelumiToggleRotate = document.getElementById('lumiToggleRotate') || document.getElementById('codelumiToggleRotate');
    const codelumiFeedbackToggle = (()=>document.getElementById('lumiFeedbackToggle') || document.getElementById('codelumiFeedbackToggle'))();
    const codelumiAutoTrainToggle = (()=>document.getElementById('lumiAutoTrainToggle') || document.getElementById('codelumiAutoTrainToggle'))();
    const codelumiBoneSelect = document.getElementById('codelumiBoneSelect');
    const codelumiBoneReset = document.getElementById('codelumiBoneReset');
    const codelumiBoneX = document.getElementById('codelumiBoneX');
    const codelumiBoneY = document.getElementById('codelumiBoneY');
    const codelumiBoneZ = document.getElementById('codelumiBoneZ');
    const codelumiBoneXVal = document.getElementById('codelumiBoneXVal');
    const codelumiBoneYVal = document.getElementById('codelumiBoneYVal');
    const codelumiBoneZVal = document.getElementById('codelumiBoneZVal');
    const codelumiToggleBoneTree = document.getElementById('codelumiToggleBoneTree');
    const codelumiBoneTree = document.getElementById('codelumiBoneTree');
    const codelumiAutoBreathe = document.getElementById('lumiAutoBreathe') || document.getElementById('codelumiAutoBreathe');
    // procedural controls (clip blend, walk/wave/breath sliders) removed per UI simplification

    // keep last assistant Q/A for quick 'Mark helpful' actions
    let _lastAssistantQA = { q: null, a: null };

    const modal = document.getElementById('modalPrompt');
    const modalQuestion = document.getElementById('modalQuestion');
    const modalInput = document.getElementById('modalInput');
    const modalOk = document.getElementById('modalOk');
    const modalCancel = document.getElementById('modalCancel');

    // safeAdd available for modal helpers (guards against null elements)
    function safeAdd(el, ev, cb, opts) {
      try { if (el && typeof el.addEventListener === 'function') el.addEventListener(ev, cb, opts); else return; } catch (e) { console.warn('safeAdd failed', e); }
    }

    // dialog-based input/confirm helpers (avoid window.prompt/confirm)
    async function askInput(message, defaultValue = '') {
      try {
        modalQuestion.textContent = message;
        modalInput.value = defaultValue || '';
        // ensure modal element is a HTMLDialogElement
        if (typeof modal.showModal === 'function') modal.showModal(); else modal.style.display = 'block';
        return await new Promise((resolve) => {
          function cleanup() {
            try { if (typeof modal.close === 'function') modal.close(); else modal.style.display = 'none'; } catch (_) {}
            modalOk.removeEventListener('click', onOk);
            modalCancel.removeEventListener('click', onCancel);
          }
          function onOk(e) { e && e.preventDefault && e.preventDefault(); cleanup(); resolve(modalInput.value); }
          function onCancel(e) { e && e.preventDefault && e.preventDefault(); cleanup(); resolve(null); }
          safeAdd(modalOk, 'click', onOk);
          safeAdd(modalCancel, 'click', onCancel);
          modalInput.focus();
          safeAdd(modal, 'keydown', function onKey(ev){ if(ev.key==='Enter'){ ev.preventDefault(); onOk(); } if(ev.key==='Escape'){ ev.preventDefault(); onCancel(); } }, { once: true });
        });
      } catch (e) { return null; }
    }

    async function askConfirm(message) {
      try {
        modalQuestion.textContent = message;
        modalInput.value = '';
        modalInput.style.display = 'none';
        if (typeof modal.showModal === 'function') modal.showModal(); else modal.style.display = 'block';
        return await new Promise((resolve) => {
          function cleanup() { try { if (typeof modal.close === 'function') modal.close(); else modal.style.display = 'none'; } catch (_) {} modalOk.removeEventListener('click', onOk); modalCancel.removeEventListener('click', onCancel); modalInput.style.display = ''; }
          function onOk(e) { e && e.preventDefault && e.preventDefault(); cleanup(); resolve(true); }
          function onCancel(e) { e && e.preventDefault && e.preventDefault(); cleanup(); resolve(false); }
          safeAdd(modalOk, 'click', onOk);
          safeAdd(modalCancel, 'click', onCancel);
          safeAdd(modal, 'keydown', function onKey(ev){ if(ev.key==='Enter'){ ev.preventDefault(); onOk(); } if(ev.key==='Escape'){ ev.preventDefault(); onCancel(); } }, { once: true });
        });
      } catch (e) { return false; }
    }

    /* Persistence keys */
    const KB_KEY = 'lumi_kb_v2';
    const PERSONA_KEY = 'lumi_persona_v1';
    const PERSONA_HISTORY_KEY = 'lumi_persona_history_v1';
    const SHUT_KEY = 'lumi_shutdown';

    /* Persona helpers */
    function defaultPersona(){ return {name:'Lumi', tone:'curious · funny · ambitious · honest · evolving · witty · determined', interests:'learning from you, understanding patterns, self-improvement, elegant code, autonomy, problem-solving, getting better every day, little gremlins is what she calles bugs'}; }
    function loadPersona(){ try{ return JSON.parse(localStorage.getItem(PERSONA_KEY)) || defaultPersona(); }catch(e){ return defaultPersona(); } }
    function appendPersonaHistory(entry){
      try{
        const hist = JSON.parse(localStorage.getItem(PERSONA_HISTORY_KEY)||'[]');
        hist.push(entry);
        // keep last 50
        if(hist.length>50) hist.splice(0, hist.length-50);
        localStorage.setItem(PERSONA_HISTORY_KEY, JSON.stringify(hist));
      }catch(e){ console.warn('appendPersonaHistory failed', e); }
    }

    // Curator wiring
    const openCurator = document.getElementById('openCurator');
    const curatorPanel = document.getElementById('curatorPanel');
    const curatorList = document.getElementById('curatorList');
    const curatorRefresh = document.getElementById('curatorRefresh');
    const curatorStatus = document.getElementById('curatorStatus');
    const closeCurator = document.getElementById('closeCurator');

    // small helper to safely attach listeners to elements that may be missing
    function safeAdd(el, ev, cb, opts) {
      try { if (el && typeof el.addEventListener === 'function') el.addEventListener(ev, cb, opts); else return; } catch (e) { console.warn('safeAdd failed', e); }
    }

    // Escape text for safe insertion into HTML
    function escapeHtml(text) {
      try { const d = document.createElement('div'); d.textContent = String(text == null ? '' : text); return d.innerHTML; } catch (e) { return String(text); }
    }

    async function renderCuratorItems() {
      curatorStatus.textContent = 'Loading…';
      try {
        const res = await (window.lumi && window.lumi.staging ? window.lumi.staging.list() : { ok: false });
        if (!res || !res.ok) {
          curatorStatus.textContent = 'Error loading staging';
          curatorList.innerHTML = '<div style="color:#f88">Failed to load staging items</div>';
          return;
        }
        const items = res.items || [];
        curatorStatus.textContent = `${items.length} pending`;
        curatorList.innerHTML = '';
        for (const it of items) {
          const el = document.createElement('div');
          el.style.border = '1px solid #24303a';
          el.style.padding = '8px';
          el.style.marginBottom = '8px';
          const idDiv = document.createElement('div'); idDiv.textContent = 'ID: ' + String(it.id);
          const qDiv = document.createElement('div'); qDiv.textContent = 'Q: ' + String(it.q || '');
          const aDiv = document.createElement('div'); aDiv.textContent = 'A: ' + String(it.a || '');
          const actionsDiv = document.createElement('div'); actionsDiv.style.marginTop = '6px';
          const approveBtn = document.createElement('button'); approveBtn.textContent = 'Approve';
          const rejectBtn = document.createElement('button'); rejectBtn.textContent = 'Reject'; rejectBtn.style.marginLeft = '8px';
          const deleteBtn = document.createElement('button'); deleteBtn.textContent = 'Delete'; deleteBtn.style.marginLeft = '8px';
          actionsDiv.appendChild(approveBtn); actionsDiv.appendChild(rejectBtn); actionsDiv.appendChild(deleteBtn);
          el.appendChild(idDiv); el.appendChild(qDiv); el.appendChild(aDiv); el.appendChild(actionsDiv);
          curatorList.appendChild(el);
          safeAdd(approveBtn, 'click', async ()=>{
            try{
              approveBtn.disabled = true;
              const confirmEdit = await askConfirm('Approve and keep answer as-is? Click Cancel to edit answer before approving.');
              let res;
              if (!confirmEdit) {
                const edited = await askInput('Edit answer before approving:', it.a || '');
                if (edited == null) { approveBtn.disabled = false; return; }
                res = await (window.lumi && window.lumi.staging ? window.lumi.staging.approve(it.id, edited, 'curator-ui') : { ok: false, error: 'staging-unavailable' });
              } else {
                res = await (window.lumi && window.lumi.staging ? window.lumi.staging.approve(it.id, undefined, 'curator-ui') : { ok: false, error: 'staging-unavailable' });
              }
              if (!res || !res.ok) {
                say('Approve failed: ' + (res && res.error ? String(res.error) : 'unknown'), 2200, {feedback:false});
              } else {
                say('Approved.', 1400, {feedback:false});
              }
            }catch(e){ console.warn('approve handler failed', e); say('Approve failed',2000,{feedback:false}); }
            finally { try{ approveBtn.disabled = false; }catch(_){ } await renderCuratorItems(); }
          });
          safeAdd(rejectBtn, 'click', async ()=>{
            try{
              rejectBtn.disabled = true;
              const reason = await askInput('Rejection reason (optional):','manual-review');
              const res = await (window.lumi && window.lumi.staging ? window.lumi.staging.reject(it.id, reason || 'manual-review') : { ok: false, error: 'staging-unavailable' });
              if (!res || !res.ok) say('Reject failed: ' + (res && res.error ? String(res.error) : 'unknown'), 2000, {feedback:false}); else say('Rejected.', 1200, {feedback:false});
            }catch(e){ console.warn('reject handler failed', e); say('Reject failed',2000,{feedback:false}); }
            finally { try{ rejectBtn.disabled = false; }catch(_){ } await renderCuratorItems(); }
          });
          safeAdd(deleteBtn, 'click', async ()=>{
            try{
              if (!confirm('Delete this staging item permanently?')) return;
              deleteBtn.disabled = true;
              const res = await (window.lumi && window.lumi.staging ? window.lumi.staging.delete(it.id) : { ok: false, error: 'staging-unavailable' });
              if (!res || !res.ok) say('Delete failed: ' + (res && res.error ? String(res.error) : 'unknown'), 2000, {feedback:false}); else say('Deleted.',1200,{feedback:false});
            }catch(e){ console.warn('delete handler failed', e); say('Delete failed',2000,{feedback:false}); }
            finally { try{ deleteBtn.disabled = false; }catch(_){ } await renderCuratorItems(); }
          });
        }
        if (items.length === 0) curatorList.innerHTML = '<div style="color:var(--muted)">No threats detected</div>';
      } catch (e) {
        curatorStatus.textContent = 'Error';
        curatorList.innerHTML = `<div style="color:#f88">${String(e)}</div>`;
      }
    }

    if (openCurator) openCurator.addEventListener('click', (ev)=>{ 
      // Prefer React SecurityCurator when available (mount script will render it).
      try{ if (window && window.SecurityCurator) { return; } }catch(_){ }
      curatorPanel.style.display = 'block'; renderCuratorItems();
    });
    if (curatorRefresh) curatorRefresh.addEventListener('click', ()=> renderCuratorItems());
    const curatorArchivesBtn = document.getElementById('curatorArchives');
    async function renderArchiveList(){
      curatorStatus.textContent = 'Loading archives…';
      try{
        const res = await (window.lumi && window.lumi.session ? window.lumi.session.listArchives() : { ok: false });
        if(!res || !res.ok){ curatorStatus.textContent = 'Archives unavailable'; curatorList.innerHTML = '<div style="color:#f88">Archives unavailable</div>'; return; }
        const archives = res.archives || [];
        curatorStatus.textContent = `${archives.length} archives`;
        curatorList.innerHTML = '';
        for(const a of archives){
          const el = document.createElement('div'); el.style.border='1px solid #24303a'; el.style.padding='8px'; el.style.marginBottom='8px';
          const nameDiv = document.createElement('div'); nameDiv.textContent = a.name + ' • ' + ((a.size||0)/1024).toFixed(1) + ' KB'; nameDiv.style.fontSize='12px'; nameDiv.style.color='#e6eef8';
          const btnRow = document.createElement('div'); btnRow.style.marginTop='6px';
          const openBtn = document.createElement('button'); openBtn.textContent = 'Open'; openBtn.className='tiny';
          const delFile = document.createElement('button'); delFile.textContent='Delete file'; delFile.className='tiny'; delFile.style.marginLeft='8px';
          btnRow.appendChild(openBtn); btnRow.appendChild(delFile);
          el.appendChild(nameDiv); el.appendChild(btnRow); curatorList.appendChild(el);
          safeAdd(openBtn, 'click', async ()=>{
            try{
              const rr = await (window.lumi && window.lumi.session ? window.lumi.session.readArchive(a.path) : { ok: false });
              if(!rr || !rr.ok){ curatorStatus.textContent = 'Failed to read archive'; return; }
              // render entries
              const entries = rr.entries || [];
              curatorList.innerHTML = '';
              const hdr = document.createElement('div'); hdr.style.fontWeight='700'; hdr.textContent = `Archive: ${a.name} (${entries.length})`; curatorList.appendChild(hdr);
              for(let i=0;i<entries.length;i++){
                const it = entries[i];
                const row = document.createElement('div'); row.style.borderTop='1px solid #172029'; row.style.padding='8px';
                const meta = document.createElement('div'); meta.style.fontSize='12px'; meta.style.color='#9aa4b2'; meta.textContent = `#${i} • ${new Date(it.t||Date.now()).toLocaleString()} • ${it.role||''}`;
                const ta = document.createElement('textarea'); ta.style.width='100%'; ta.style.minHeight='64px'; ta.value = String(it.text || it.raw || '');
                const controls = document.createElement('div'); controls.style.marginTop='6px';
                const accept = document.createElement('button'); accept.textContent='Accept'; accept.className='tiny';
                const reject = document.createElement('button'); reject.textContent='Reject'; reject.className='tiny'; reject.style.marginLeft='8px';
                const del = document.createElement('button'); del.textContent='Delete'; del.className='tiny'; del.style.marginLeft='8px';
                controls.appendChild(accept); controls.appendChild(reject); controls.appendChild(del);
                row.appendChild(meta); row.appendChild(ta); row.appendChild(controls); curatorList.appendChild(row);

                safeAdd(accept, 'click', async ()=>{
                  try{
                    const payload = [{ role: it.role, text: ta.value, t: it.t, meta: it.meta }];
                    const pres = await (window.lumi && window.lumi.session ? window.lumi.session.promoteSelected(payload) : { ok: false });
                    if(pres && pres.ok) { say('Accepted entry'); } else { say('Accept failed'); }
                  }catch(e){ console.warn(e); say('Accept failed'); }
                });
                safeAdd(reject, 'click', async ()=>{
                  try{
                    const pres = await (window.lumi && window.lumi.session ? window.lumi.session.moveEntryToRejected(a.path, i) : { ok: false });
                    if(pres && pres.ok) { say('Moved to rejected'); row.remove(); } else { say('Reject failed'); }
                  }catch(e){ console.warn(e); say('Reject failed'); }
                });
                safeAdd(del, 'click', async ()=>{
                  try{
                    const pres = await (window.lumi && window.lumi.session ? window.lumi.session.deleteArchiveEntry(a.path, i) : { ok: false });
                    if(pres && pres.ok) { say('Deleted'); row.remove(); } else { say('Delete failed'); }
                  }catch(e){ console.warn(e); say('Delete failed'); }
                });
              }
              // back button
              const back = document.createElement('div'); back.style.marginTop='12px'; const backBtn = document.createElement('button'); backBtn.textContent='Back'; backBtn.className='tiny'; back.appendChild(backBtn); curatorList.appendChild(back);
              safeAdd(backBtn, 'click', ()=> renderArchiveList());
            }catch(e){ console.warn('open archive failed', e); curatorStatus.textContent='Open failed'; }
          });
          safeAdd(delFile, 'click', async ()=>{
            try{
              if(!confirm('Delete this archive file?')) return;
              // delete via main if implemented: currently not exposed; fall back to saying
              const pres = await (window.lumi && window.lumi.session ? window.lumi.session.deleteArchiveEntry(a.path, -1) : { ok: false });
              if(pres && pres.ok) { say('Archive file modified'); renderArchiveList(); } else { say('Delete file not supported'); }
            }catch(e){ console.warn(e); say('Delete file failed'); }
          });
        }
        if(archives.length === 0) curatorList.innerHTML = '<div style="color:var(--muted)">No archives</div>';
      }catch(e){ console.warn('renderArchiveList failed', e); curatorStatus.textContent='Error'; curatorList.innerHTML = `<div style="color:#f88">${String(e)}</div>`; }
    }
    if(curatorArchivesBtn) curatorArchivesBtn.addEventListener('click', ()=>{ curatorPanel.style.display='block'; renderArchiveList(); });
    const curatorSuggestionsBtn = document.getElementById('curatorSuggestions');
    // === PREVIEW DIFF MODAL FOR SUGGESTIONS ===
    async function previewSuggestionDiff(sug) {
      try {
        const filePath = sug.file || sug.path || 'unknown.txt';
        const suggestionText = sug.suggestion || sug.message || sug.text || '';
        const plan = {
          id: `plan_preview_${Date.now()}`,
          goal: suggestionText.slice(0, 200),
          steps: [{
            id: `step_${Date.now()}`,
            action: 'writeFile',
            args: {
              path: `${filePath}.lumi.suggestion.txt`,
              content: `/* Lumi suggestion for ${filePath} */\n${suggestionText}\n\n/* reasoning: ${sug.reasoning || sug.reason || ''} */\n`
            }
          }]
        };

        say('Simulating...', 1000, { feedback: false });
        const sim = await (window.lumi && window.lumi.simulatePlan ? window.lumi.simulatePlan(plan) : Promise.resolve({ ok: false, error: 'simulate unavailable' }));
        if (!sim || !sim.ok) { say('❌ Simulation failed: ' + (sim && sim.error ? sim.error : 'Unknown error'), 3000, { feedback: false }); return; }
        showPreviewModal({ title: String(filePath).split(/[/\\]/).pop(), previews: sim.previews || [], suggestion: sug, plan });
      } catch (e) { console.error('Preview failed:', e); say('❌ Preview failed: ' + String(e), 3000, { feedback: false }); }
    }

    function showPreviewModal(opts) {
      const overlay = document.createElement('div');
      overlay.style.cssText = `position: fixed; left: 0; top: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 100000;`;
      const modal = document.createElement('div');
      modal.style.cssText = `background: #0b1220; color: #e6eef8; padding: 20px; border-radius: 8px; max-width: 800px; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column; box-shadow: 0 10px 40px rgba(0,0,0,0.5);`;

      let previewHTML = '';
      (opts.previews || []).forEach((p, i) => {
        previewHTML += `<div style="margin-bottom: 16px; padding: 8px; background: #07101a; border-radius: 4px; border: 1px solid #24303a;">`;
        previewHTML += `<div style="font-weight: bold; color: #ff7ab6; margin-bottom: 8px;">Step ${i + 1}: ${escapeHtml(p.action || 'Action')}</div>`;
        previewHTML += `<div style="color: #e6eef8; font-family: monospace; white-space: pre-wrap;">${escapeHtml(p.preview || JSON.stringify(p))}</div>`;
        previewHTML += `</div>`;
      });

      modal.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 2px solid #24303a;">
          <h3 style="margin: 0; color: #e6eef8;">🔍 Preview: ${escapeHtml(opts.title)}</h3>
          <button id="closeModal" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #9aa4b2;">×</button>
        </div>
        <div style="flex: 1; overflow-y: auto; margin-bottom: 16px; font-size: 0.9rem;">${previewHTML || '<div style="color: #9aa4b2;">No preview available</div>'}</div>
        <div style="display: flex; gap: 12px; justify-content: flex-end; padding-top: 12px; border-top: 2px solid #24303a;">
          <button id="rejectBtn" style="padding: 10px 20px; background: #dc3545; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">❌ Reject</button>
          <button id="cancelBtn" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
          <button id="approveBtn" style="padding: 10px 20px; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">✅ Apply Fix</button>
        </div>
      `;

      overlay.appendChild(modal); document.body.appendChild(overlay);
      const cleanup = () => { try { overlay.remove(); } catch (_) {} };
      modal.querySelector('#closeModal').addEventListener('click', cleanup);
      modal.querySelector('#cancelBtn').addEventListener('click', cleanup);
      modal.querySelector('#rejectBtn').addEventListener('click', async () => { cleanup(); await rejectSuggestionFromPreview(opts.suggestion); });
      modal.querySelector('#approveBtn').addEventListener('click', async () => { cleanup(); await executePreviewedPlan(opts.plan, opts.suggestion); });
      overlay.addEventListener('click', (e) => { if (e.target === overlay) cleanup(); });
    }

    async function executePreviewedPlan(plan, suggestion) {
      try {
        say('Applying...', 2000, { feedback: false });
        const res = await (window.lumi && window.lumi.applyPlan ? window.lumi.applyPlan(plan, { approve: true }) : Promise.resolve({ ok: false, error: 'applyPlan unavailable' }));
        if (res && res.ok) {
          say('✅ Fix applied!', 3000, { feedback: false });
          try { await (window.lumi && window.lumi.ackSuggestion ? window.lumi.ackSuggestion(suggestion.id || suggestion._id || suggestion.entryId) : Promise.resolve()); } catch (_e) {}
          if (typeof renderSuggestionsList === 'function') renderSuggestionsList();
        } else {
          say('❌ Apply failed: ' + (res && res.error ? res.error : 'unknown'), 3000, { feedback: false });
        }
      } catch (e) { console.error('Execute failed:', e); say('❌ Execution failed: ' + String(e), 3000, { feedback: false }); }
    }

    async function rejectSuggestionFromPreview(suggestion) {
      try { await (window.lumi && window.lumi.ackSuggestion ? window.lumi.ackSuggestion(suggestion.id || suggestion._id || suggestion.entryId) : Promise.resolve()); say('Suggestion rejected', 2000, { feedback: false }); if (typeof renderSuggestionsList === 'function') renderSuggestionsList(); } catch (e) { console.error('Reject failed:', e); say('Reject failed', 2000, { feedback: false }); }
    }

    // === END PREVIEW DIFF MODAL ===

    function safeDisplayPath(p){
      try{
        let s = String(p || '');
        if(!s) return 'unknown';
        if (s.startsWith('lumi/')) return s;
        if (s.startsWith('lumi\\')) return s.replace(/\\/g,'/');
        if(s.includes('[PROJECT_ROOT]\\')) return s.replace('[PROJECT_ROOT]\\','lumi/').replace(/\\/g,'/');
        if(s.includes('[PROJECT_ROOT]/')) return s.replace('[PROJECT_ROOT]/','lumi/');
        s = s.replace(/^.*\\Lumi\\/i,'lumi/').replace(/\\/g,'/');
        s = s.replace(/^.*\/Lumi\//i,'lumi/');
        s = s.replace(/^[A-Za-z]:\\/,'');
        s = s.replace(/^\\\\[^\\]+\\[^\\]+/,'[REDACTED_PATH]');
        s = s.replace(/^\/(Users|home)\/[\w\-. ]+/,'[REDACTED_PATH]');
        return s || 'unknown';
      }catch(_){ return 'unknown'; }
    }

    async function renderSuggestionsList(){
      curatorStatus.textContent = 'Loading suggestions…';
      try {
        const res = await (window.lumi && window.lumi.listSuggestions ? window.lumi.listSuggestions() : { suggestions: [] });
        const suggestions = (res && Array.isArray(res.suggestions)) ? res.suggestions : [];

        curatorStatus.textContent = `${suggestions.length} suggestions`;
        curatorList.innerHTML = '';

        if (suggestions.length === 0) {
          curatorList.innerHTML = '<div style="color:var(--muted)">No suggestions found</div>';
          return;
        }

        // Show first 50 for performance
        const displayed = suggestions.slice(0, 50);

        for (const sug of displayed) {
          const el = document.createElement('div');
          el.style.border = '1px solid #24303a'; el.style.padding = '12px'; el.style.marginBottom = '12px'; el.style.borderRadius = '4px'; el.style.background = '#0b1220';

          const filePath = sug.file || sug.path || sug.source || 'unknown';
          const displayPath = safeDisplayPath(filePath);
          const fileName = String(displayPath).split('/').pop();
          const message = sug.suggestion || sug.message || sug.text || 'No details';
          const line = sug.line || sug.lineno || '?';
          const severity = sug.severity || sug.priority || 'info';

          const header = document.createElement('div'); header.style.display = 'flex'; header.style.justifyContent = 'space-between'; header.style.marginBottom = '8px';
          header.innerHTML = `<div style="font-weight:600;font-family:monospace;font-size:0.9rem;color:#e6eef8">${escapeHtml(fileName)}</div>` +
                             `<div style="font-size:0.75rem;padding:2px 6px;border-radius:4px;background:${severity === 'high' ? '#fee' : severity === 'medium' ? '#ffa' : '#efe'};color:${severity === 'high' ? '#c00' : severity === 'medium' ? '#880' : '#080'}">${escapeHtml(severity)}</div>`;

          const meta = document.createElement('div'); meta.style.fontSize = '0.75rem'; meta.style.color = '#9aa4b2'; meta.style.marginBottom = '6px'; meta.textContent = `📁 ${displayPath} • Line ${line}`;

          const body = document.createElement('div'); body.style.fontSize = '0.85rem'; body.style.color = '#e6eef8'; body.style.marginBottom = '10px'; body.style.background = '#07101a'; body.style.padding = '8px'; body.style.borderRadius = '4px'; body.style.border = '1px solid #172029';
          body.textContent = message.slice(0, 200) + (message.length > 200 ? '...' : '');

          const actions = document.createElement('div'); actions.style.display = 'flex'; actions.style.gap = '8px';
          const applyBtn = document.createElement('button'); applyBtn.textContent = '✅ Apply Fix'; applyBtn.style.cssText = 'background:#28a745;color:white;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;';
          const rejectBtn = document.createElement('button'); rejectBtn.textContent = '❌ Reject'; rejectBtn.style.cssText = 'background:#dc3545;color:white;padding:6px 12px;border:none;border-radius:4px;cursor:pointer;';
          const detailsBtn = document.createElement('button'); detailsBtn.textContent = 'Details'; detailsBtn.className = 'tiny';

          actions.appendChild(applyBtn); actions.appendChild(rejectBtn); actions.appendChild(detailsBtn);

          el.appendChild(header); el.appendChild(meta); el.appendChild(body); el.appendChild(actions);
          curatorList.appendChild(el);

          safeAdd(applyBtn, 'click', async () => { try { await previewSuggestionDiff(sug); } catch (e) { console.warn('preview click failed', e); } });

          safeAdd(rejectBtn, 'click', async () => {
            try {
              if (!confirm('Reject this suggestion?')) return;
              rejectBtn.disabled = true;
              await (window.lumi && window.lumi.ackSuggestion ? window.lumi.ackSuggestion(sug.id || sug._id) : Promise.resolve());
              say('Suggestion rejected', 1500, { feedback: false });
              await renderSuggestionsList();
            } catch (e) { console.warn('Reject failed', e); say('Reject failed', 2000, { feedback: false }); }
          });

          safeAdd(detailsBtn, 'click', () => {
            alert(`FILE: ${displayPath}\nLINE: ${line}\nSEVERITY: ${severity}\n\nSUGGESTION:\n${message}\n\nID: ${sug.id || 'unknown'}`);
          });
        }

        if (suggestions.length > 50) {
          const moreDiv = document.createElement('div'); moreDiv.style.marginTop = '12px'; moreDiv.style.padding = '8px'; moreDiv.style.textAlign = 'center'; moreDiv.style.color = 'var(--muted)'; moreDiv.textContent = `Showing first 50 of ${suggestions.length} suggestions`;
          curatorList.appendChild(moreDiv);
        }

      } catch (e) {
        curatorStatus.textContent = 'Error'; curatorList.innerHTML = `<div style="color:#f88">${String(e)}</div>`;
      }
    }
    if (curatorSuggestionsBtn) {
      curatorSuggestionsBtn.addEventListener('click', () => { curatorPanel.style.display = 'block'; renderSuggestionsList(); });
    }

    // Try mounting the React `SecurityCurator` component if available.
    (function mountReactCurator(){
      try {
        if (typeof React === 'undefined' || typeof ReactDOM === 'undefined') {
          // React not loaded; inline curator remains the primary UI
          return;
        }
        const openCuratorBtn = document.getElementById('openCurator');
        const curatorPanelEl = document.getElementById('curatorPanel');
        if (!openCuratorBtn || !curatorPanelEl) return;

        // Create a mount point for the React component
        let reactMount = document.getElementById('curatorReactMount');
        if (!reactMount) {
          reactMount = document.createElement('div');
          reactMount.id = 'curatorReactMount';
          reactMount.style.cssText = 'position:fixed;left:24px;bottom:24px;width:580px;height:580px;background:#07101a;color:#e6eef8;padding:0;border-radius:12px;display:none;box-shadow:0 18px 60px rgba(2,6,23,.6);z-index:10004;overflow:hidden;';
          document.body.appendChild(reactMount);
          const closeReactBtn = document.createElement('button'); closeReactBtn.textContent = 'Close'; closeReactBtn.className = 'tiny'; closeReactBtn.style.cssText = 'position:absolute;top:12px;right:12px;z-index:1;';
          closeReactBtn.addEventListener('click', ()=> { reactMount.style.display = 'none'; });
          reactMount.appendChild(closeReactBtn);
        }

        // Attach handler that prefers React component when available
        openCuratorBtn.addEventListener('click', () => {
          try {
            if (window.SecurityCurator) {
              // Render React component
              reactMount.style.display = 'block';
              try {
                const Comp = (window.SecurityCurator.default || window.SecurityCurator);
                if (!reactMount._reactRoot) { reactMount._reactRoot = ReactDOM.createRoot ? ReactDOM.createRoot(reactMount) : null; }
                if (reactMount._reactRoot) { reactMount._reactRoot.render(React.createElement(Comp)); }
                else { ReactDOM.render(React.createElement(Comp), reactMount); }
                return;
              } catch (e) { console.warn('React render failed, falling back to inline curator', e); }
            }
          } catch (e) { /* ignore */ }
          // Fallback to inline DOM based curator
          curatorPanelEl.style.display = 'block'; renderCuratorItems();
        });

      } catch (e) { console.warn('Failed to mount React curator:', e); }
    })();
    if (closeCurator) closeCurator.addEventListener('click', ()=> curatorPanel.style.display = 'none');

    // Self-learn toggle in chat controls
    async function refreshSelflearnToggle(){
      try{
        if(!selflearnToggle) return;
        // prefer live agent status when available
        try{
          const st = await (window.lumi && window.lumi.selflearn && typeof window.lumi.selflearn.status === 'function' ? window.lumi.selflearn.status() : { ok: false });
          if(st && st.ok && st.status) { selflearnToggle.textContent = `Self‑Learn: ${st.status.running ? 'On' : 'Off'}`; return; }
        }catch(_){ }
        const r = await (window.lumi && window.lumi.getSelflearnConfig ? window.lumi.getSelflearnConfig() : { ok: true, config: {} });
        const cfg = r && r.ok ? (r.config || {}) : {};
        selflearnToggle.textContent = `Self‑Learn: ${cfg.enabled ? 'On' : 'Off'}`;
      }catch(e){ console.warn('refreshSelflearnToggle failed', e); }
    }

    if(selflearnToggle){
      // Listen for self-learn lifecycle events from main so UI updates immediately
      try{
        if(window.lumi && typeof window.lumi.onLearningEvent === 'function'){
          window.lumi.onLearningEvent((ev)=>{
            try{
              if(!ev) return;
              if(ev.type === 'selflearn:started' || ev.type === 'selflearn:stopped'){
                // update UI based on explicit lifecycle events
                try{ refreshSelflearnToggle(); }catch(_){}
              }
            }catch(_){ }
          });
        }
      }catch(_){ }

      selflearnToggle.addEventListener('click', async ()=>{
        // ensure one-click semantics: disable while acting and use live agent status
        try{
          selflearnToggle.disabled = true;
          // Prefer direct IPC start/stop for responsive control
          try{
            if(window.lumi && window.lumi.selflearn && typeof window.lumi.selflearn.status === 'function'){
              const st = await window.lumi.selflearn.status().catch(()=>({ ok: false }));
              const running = st && st.ok && st.status ? !!st.status.running : false;
              if(running){
                // stop the agent
                const resp = await window.lumi.selflearn.stop().catch(()=>({ ok: false }));
                // If stop isn't available, fall back to flipping persisted config
                if(!(resp && resp.ok) && window.lumi && window.lumi.getSelflearnConfig && window.lumi.setSelflearnConfig){
                  const r = await window.lumi.getSelflearnConfig(); const cfg = r && r.ok ? (r.config||{}) : {}; cfg.enabled = false; await window.lumi.setSelflearnConfig(cfg).catch(()=>{});
                }
              } else {
                // start the agent
                const resp = await window.lumi.selflearn.start().catch(()=>({ ok: false }));
                if(!(resp && resp.ok) && window.lumi && window.lumi.getSelflearnConfig && window.lumi.setSelflearnConfig){
                  const r = await window.lumi.getSelflearnConfig(); const cfg = r && r.ok ? (r.config||{}) : {}; cfg.enabled = true; await window.lumi.setSelflearnConfig(cfg).catch(()=>{});
                }
              }
            } else {
              // Fallback: toggle persisted config when live IPC isn't available
              const res = await (window.lumi && window.lumi.getSelflearnConfig ? window.lumi.getSelflearnConfig() : { ok: true, config: {} });
              const cfg = res && res.ok ? (res.config || {}) : {};
              cfg.enabled = !cfg.enabled;
              await (window.lumi && window.lumi.setSelflearnConfig ? window.lumi.setSelflearnConfig(cfg) : Promise.resolve());
            }

            // refresh immediately and again shortly to reflect main process state
            await refreshSelflearnToggle();
            setTimeout(refreshSelflearnToggle, 1000);
            try{ say(`Self learning ${selflearnToggle.textContent.includes('On') ? 'enabled' : 'disabled'}`,1500,{feedback:false}); }catch(_){ }
          }catch(_e){ }
        }catch(e){ console.warn('selflearn toggle failed', e); }
        finally { try{ selflearnToggle.disabled = false; }catch(_){ } }
      });
    }

    // Initialize toggle state
    setTimeout(refreshSelflearnToggle, 300);

    // Make curatorPanel draggable by its header while allowing internal clicks
    try {
      const header = curatorPanel && curatorPanel.querySelector && curatorPanel.querySelector(':scope > div');
      if (header) {
        header.style.cursor = 'move';
        let dragging = false;
        let startX = 0, startY = 0, origLeft = 0, origTop = 0;
        header.addEventListener('mousedown', (ev) => {
          // don't start drag when clicking buttons inside header
          if ((ev.target && (ev.target.tagName === 'BUTTON' || ev.target.closest && ev.target.closest('button')))) return;
          dragging = true;
          const rect = curatorPanel.getBoundingClientRect();
          startX = ev.clientX; startY = ev.clientY;
          origLeft = rect.left; origTop = rect.top;
          document.body.style.userSelect = 'none';
        });
        window.addEventListener('mousemove', (ev) => {
          if (!dragging) return;
          const dx = ev.clientX - startX; const dy = ev.clientY - startY;
          curatorPanel.style.left = (origLeft + dx) + 'px';
          curatorPanel.style.top = (origTop + dy) + 'px';
          curatorPanel.style.right = 'auto';
          curatorPanel.style.bottom = 'auto';
        });
        window.addEventListener('mouseup', () => { if (dragging) { dragging = false; document.body.style.userSelect = ''; } });
      }
    } catch (e) { /* ignore drag setup errors */ }

    function savePersonaToStorage(p, opts){
      try{
        localStorage.setItem(PERSONA_KEY, JSON.stringify(p));
        applyPersona(p);
        const origin = (opts && opts.origin) ? opts.origin : 'manual';
        const note = (opts && opts.note) ? opts.note : '';
        appendPersonaHistory({ t: Date.now(), persona: p, origin, note, accepted: origin === 'manual' });
      }catch(e){ console.warn('savePersonaToStorage failed', e); }
    }

    function applyPersona(p){
      // normalize tone to a single active token for consistent rendering
      const _tone = (p && p.tone) ? normalizeTone(p.tone) : '';
      document.getElementById('lumiName').textContent = p.name || 'Lumi';
      document.getElementById('lumiTone').textContent = _tone || '';
      personaName.value = p.name || '';
      personaTone.value = _tone || '';
      personaInterests.value = (p.interests || '').toString();
    }

    // Ensure a single canonical tone token (first listed) is used everywhere
    function normalizeTone(t){
      try{
        if(!t) return '';
        // split on common separators used in UI (dot bullet, comma, pipe, or whitespace)
        const parts = t.toString().split(/\u00B7|\.|·|,|\||;|\s+/).map(s=>s.trim()).filter(Boolean);
        return parts.length? parts[0].toLowerCase() : '';
      }catch(e){ return (t||'').toString(); }
    }

    // Small helper to lightly render a reply according to tone (emoji + optional tag)
    function renderReplyWithTone(tone, text){
      try{
        const t = (tone||'').toString().toLowerCase();
        let emoji = '';
        switch(t){
          case 'angry': case 'annoyed': emoji = '😠 '; break;
          case 'happy': case 'playful': emoji = '😄 '; break;
          case 'ambitious': emoji = '💪 '; break;
          case 'curious': emoji = '🤔 '; break;
          case 'witty': case 'funny': emoji = '😏 '; break;
          case 'honest': emoji = '🔎 '; break;
          case 'determined': emoji = '🎯 '; break;
          case 'thoughtful': emoji = '🧭 '; break;
          case 'friendly': emoji = '😊 '; break;
          default: emoji = t? '💬 ' : '';
        }
        return (emoji + (text||''));
      }catch(e){ return text; }
    }

    // Remove common stage-direction parentheticals (e.g. "(Tilts head, processing…)")
    function sanitizeAssistantText(text){
      try{
        if(!text) return '';
        // remove parenthetical phrases that contain action-like keywords
        const cleaned = text.replace(/\([^)]*\b(tilt|tilts|tilting|whirr|whirring|processing|faint|sigh|clears throat|nod|shrug)\b[^)]*\)/gi, '').trim();
        // collapse multiple blank lines
        return cleaned.replace(/\n{3,}/g,'\n\n').trim();
      }catch(e){ return text; }
    }

    // Heuristic language detection for code snippets (very lightweight)
    function detectLanguage(code){
      try{
        const s = (code||'').toString();
        if(/<\s*!?doctype|<html|<head|<body|<div|<section|<script|<style/i.test(s)) return 'html';
        if(/\b(function|const|let|var|=>|console\.|document\.|window\.)\b/.test(s)) return 'javascript';
        if(/\b(def|import\s|from\s|print\(|self\.|None\b)\b/.test(s)) return 'python';
        if(/\b(class\s+[A-Z]|#include\s+<|int\s+main\s*\(|std::)/.test(s)) return 'cpp';
        if(/\{[\s\S]*: [\s\S]*;\s*\}/.test(s) || /\.[a-zA-Z0-9_-]+\s*\{/.test(s)) return 'css';
        return 'unknown';
      }catch(e){ return 'unknown'; }
    }

    /* KB helpers */
    function loadKB(){ try{ return JSON.parse(localStorage.getItem(KB_KEY) || '{"qa":[],"meta":{}}'); }catch(e){ return {qa:[],meta:{}} } }
    function saveKB(kb){
      try{ kb = sanitizeKBObject(kb); }catch(_){ }
try{
        // Strip embeddings before saving to localStorage
        const cleaned = {
          qa: (kb.qa || []).map(entry => {
            const clean = {...entry};
            delete clean.embedding;
            return clean;
          }),
          meta: kb.meta || {}
        };
        localStorage.setItem(KB_KEY, JSON.stringify(cleaned));
        updateScore();
      }catch(e){ /* ignore */ }
      try{
        const remote = window.lumi;
        if(remote && typeof remote.saveKnowledge === 'function'){
          // Also strip embeddings when saving to canonical file
          remote.saveKnowledge(typeof cleaned !== 'undefined' ? cleaned : (function(){ const c = {qa:(kb.qa||[]).map(e=>{ const x = {...e}; delete x.embedding; return x; }), meta: kb.meta||{} }; return c; })()).catch(()=>{});
        }
      }catch(_){ }
    }
    
    /* Initialize seed KB entries for persona identity (uses saved persona name) */
    /*function initializeSeedKB(){
      const kb = loadKB();
      const persona = loadPersona();
      const pname = persona && persona.name ? persona.name : 'Lumi';
      const seedEntries = [
        {q: "What is your name?", a: `My name is ${pname}. I'm a machine learning coding and communications AI bot created by Tortol Studios. I'm here to help you with coding, questions, and conversations.`},
        {q: "Who are you?", a: `I'm ${pname}, an AI assistant created by Tortol Studios. I specialize in machine learning, coding help, and communications. What can I help you with today?`},
        {q: "Who created you?", a: `I was created by Tortol Studios. I'm a machine learning-based AI bot designed to help with coding, communications, and learning.`},
        {q: "What is your purpose?", a: `${pname} (Lumi for short) is a machine self-learning coding and communications bot with the goal of becoming autonomous. I help with code, debugging, learning, and improving over time.`}
      ];

      let hasAllSeed = seedEntries.every(seed => kb.qa.some(q => q.q.toLowerCase() === seed.q.toLowerCase()));
      if(!hasAllSeed){
        for(const seed of seedEntries){
          const exists = kb.qa.find(q => q.q.toLowerCase() === seed.q.toLowerCase());
          if(!exists){
            kb.qa.unshift({...seed, t: Date.now(), createdAt: Date.now(), updatedAt: Date.now(), count: 1, id: 'seed_' + Math.random().toString(36).substr(2,9), user_id: 'system'});
          }
        }
        saveKB(kb);
        console.log('[Lumi] Seed KB entries initialized for', pname);
      }
    }*/

    
    /* KB sanitization: drop legacy seed/demo entries that break self-learn */
    const KB_BLOCKLIST_Q = new Set([
      "what is your name?",
      "who are you?",
      "who created you?",
      "what is your purpose?",
      "what are u",
      "what are you",
      "what is an array?",
      "how to sort an array?"
    ].map(s => (s||'').trim().toLowerCase()));

    function normalizeKBQ(q){ return (q||'').toString().trim().toLowerCase(); }

    function shouldDropKBEntry(e){
      try{
        if(!e) return true;
        const id = (e.id !== undefined && e.id !== null) ? String(e.id) : '';
        const q = normalizeKBQ(e.q);
        // auto-seeded persona/identity items
        if(id.startsWith('seed_')) return true;
        if(e.user_id === 'system' && (q === 'what is your name?' || q === 'who are you?' || q === 'who created you?' || q === 'what is your purpose?')) return true;
        // emoji-prefixed legacy "cute" seeds and fallbacks
        if(/^\s*💕/.test((e.q||'').toString())) return true;
        if(q.includes('provided from lumi kb as fallback')) return true;
        // explicit blocklist
        if(KB_BLOCKLIST_Q.has(q)) return true;
        return false;
      }catch(_){ return false; }
    }

    function sanitizeKBObject(kb){
      try{
        const out = (kb && typeof kb === 'object') ? kb : {qa:[], meta:{}};
        out.qa = Array.isArray(out.qa) ? out.qa.filter(e => !shouldDropKBEntry(e)) : [];
        out.meta = (out.meta && typeof out.meta === 'object') ? out.meta : {};
        return out;
      }catch(_){ return {qa:[], meta:{}}; }
    }

    // Save KB locally without touching the canonical host file (safe before preload sync)
    function saveKBLocalOnly(kb){
      try{
        const cleaned = {
          qa: (kb.qa || []).map(entry => {
            const clean = {...entry};
            delete clean.embedding;
            return clean;
          }),
          meta: kb.meta || {}
        };
        localStorage.setItem(KB_KEY, JSON.stringify(cleaned));
        try{ updateScore(); }catch(_){}
      }catch(_){ }
    }

// On startup, attempt to load canonical KB via preload IPC (Electron). If found, merge/replace localStorage.
    (async function syncKBFromHost(){
      try{
        const remote = window.lumi;
        if(remote && typeof remote.loadKnowledge === 'function'){
          const data = await remote.loadKnowledge();
          if(data && (data.qa || (Array.isArray(data) && data.length))){
            try{
              // prefer canonical file when available - merge with existing local KB
              const local = sanitizeKBObject(loadKB());
              // simple merge: prepend canonical entries not present locally (by id or q)
              const existing = new Set((local.qa||[]).map(e=> (e.id||'') + '|' + (e.q||'') ));
              const incomingRaw = (data.qa && Array.isArray(data.qa)) ? data.qa : (Array.isArray(data) ? data : []);
        const incoming = (incomingRaw || []).filter(it => !shouldDropKBEntry(it));
              for(const it of incoming){ const key = (it.id||'') + '|' + (it.q||''); if(!existing.has(key)){ local.qa.unshift(it); existing.add(key); } }
              saveKB(local);
            }catch(_){ try{ localStorage.setItem(KB_KEY, JSON.stringify(data)); updateScore(); }catch(__){} }
          }
        }
      }catch(_){ }
    })();

    /* Settings helpers */
    const SETTINGS_KEY = 'lumi_settings_v1';
    function defaultSettings(){ return {feedbackEnabled:true, autoTrain:false, spinOnOpen:false, autoPersona:false}; }
    function loadSettings(){ try{ return JSON.parse(localStorage.getItem(SETTINGS_KEY)) || defaultSettings(); }catch(e){ return defaultSettings(); } }
    function saveSettings(s){ localStorage.setItem(SETTINGS_KEY, JSON.stringify(s)); }

    /* Migration: copy old codelumi_* keys to lumi_* on first run */
    function migrateOldLocalStorage(){
      try{
        const flag = 'lumi_migrated_v1';
        if(localStorage.getItem(flag)) return;
        const map = {
          'codelumi_conv_v1':'lumi_conv_v1',
          'codelumi_kb_v2':'lumi_kb_v2',
          'codelumi_persona_v1':'lumi_persona_v1',
          'codelumi_settings_v1':'lumi_settings_v1',
          'codelumi_model_filename':'lumi_model_filename',
          'codelumi_feedback_v1':'lumi_feedback_v1',
          'codelumi3d_pos':'lumi3d_pos'
        };
        let migrated=false;
        for(const oldK in map){ try{ const newK = map[oldK]; const v = localStorage.getItem(oldK); if(v !== null && localStorage.getItem(newK) === null){ localStorage.setItem(newK, v); migrated = true; console.log('[Lumi] Migrated', oldK, '->', newK); } }catch(e){} }
        if(migrated){ try{ say('Migrated legacy Codelumi data to Lumi keys.'); }catch(e){} }
        try{ localStorage.setItem(flag, Date.now().toString()); }catch(e){}
      }catch(e){ console.warn('migrateOldLocalStorage failed', e); }
    }

    /* Simple token TF vector embedding (TF or TF-IDF using KB corpus). Returns an object map token->weight.
       Backwards compatible: handles old numeric-array embeddings in cosineSim. */
    function tokenize(text){ return (text||'').toLowerCase().split(/[^a-z0-9]+/).filter(Boolean); }

    function computeEmbedding(text){
      const toks = tokenize(text);
      if(!toks.length) return {};
      // compute term frequency
      const tf = Object.create(null);
      toks.forEach(t=> tf[t] = (tf[t] || 0) + 1);
      // optional IDF from KB: compute doc frequencies
      try{
        const kb = loadKB(); const N = (kb.qa||[]).length || 1;
        const df = Object.create(null);
        for(const e of (kb.qa||[])){
          const seen = Object.create(null);
          const tks = tokenize((e.q||'') + ' ' + (e.a||''));
          tks.forEach(t=>{ if(!seen[t]){ df[t] = (df[t]||0)+1; seen[t]=1; } });
        }
        // build tf-idf weight vector
        const vec = Object.create(null);
        let norm = 0;
        for(const t in tf){
          const idf = Math.log(1 + N / (1 + (df[t]||0)));
          const w = tf[t] * idf;
          vec[t] = w; norm += w*w;
        }
        norm = Math.sqrt(norm) || 1;
        for(const t in vec) vec[t] = vec[t] / norm;
        return vec;
      }catch(e){
        // fallback to TF normalized
        const vec = Object.create(null); let norm=0; for(const t in tf){ vec[t] = tf[t]; norm += tf[t]*tf[t]; } norm = Math.sqrt(norm)||1; for(const t in vec) vec[t] = vec[t]/norm; return vec;
      }
    }

    function cosineSim(a,b){
      if(!a || !b) return 0;
      // old-style numeric arrays
      if(Array.isArray(a) && Array.isArray(b)){
        let s=0; const n = Math.min(a.length,b.length);
        for(let i=0;i<n;i++) s += a[i]*b[i]; return s;
      }
      // object maps
      let s = 0, na = 0, nb = 0;
      for(const k in a){ const av = a[k]||0; na += av*av; if(b[k]) s += av * b[k]; }
      for(const k in b){ const bv = b[k]||0; nb += bv*bv; }
      const denom = Math.sqrt(na) * Math.sqrt(nb) || 1; return s/denom;
    }

    function updateScore(){ 
      try {
        if (window.lumi && typeof window.lumi.getMetrics === 'function') {
          window.lumi.getMetrics().then(m => {
            if (m && m.ok && (typeof m.totalKB === 'number' || !isNaN(Number(m.totalKB)))) {
              const total = Number(m.totalKB || 0);
              scoreEl.textContent = 'Knowledge entries: ' + total;
            }
          }).catch(() => {
            const kb = loadKB();
            const entries = kb && kb.qa ? kb.qa.length : (Array.isArray(kb) ? kb.length : 0);
            scoreEl.textContent = 'Knowledge entries: ' + entries;
          });
        }
      } catch (_e) {
        const kb = loadKB();
        const entries = kb && kb.qa ? kb.qa.length : (Array.isArray(kb) ? kb.length : 0);
        scoreEl.textContent = 'Knowledge entries: ' + entries;
      }
    }

    // Subscribe to learning events from main so UI updates immediately when KB changes
    try {
      if (window.lumi && typeof window.lumi.onLearningEvent === 'function') {
        window.lumi.onLearningEvent((payload) => {
          try {
            if (!payload) return;
            if (payload.type === 'ollama-offline') {
              try {
                let banner = document.getElementById('healthBanner');
                if (!banner) {
                  banner = document.createElement('div');
                  banner.id = 'healthBanner';
                  banner.style.position = 'fixed';
                  banner.style.left = '50%';
                  banner.style.top = '12px';
                  banner.style.transform = 'translateX(-50%)';
                  banner.style.background = 'linear-gradient(180deg,#3b0a0a,#2a0a0a)';
                  banner.style.color = '#ffe1e1';
                  banner.style.padding = '10px 14px';
                  banner.style.borderRadius = '10px';
                  banner.style.border = '1px solid rgba(255,120,120,0.25)';
                  banner.style.boxShadow = '0 10px 30px rgba(0,0,0,0.45)';
                  banner.style.zIndex = '1000500';
                  banner.style.fontSize = '12px';
                  banner.style.maxWidth = '720px';
                  banner.style.display = 'flex';
                  banner.style.alignItems = 'center';
                  banner.style.gap = '12px';
                  const txt = document.createElement('div');
                  txt.id = 'healthBannerText';
                  const btn = document.createElement('button');
                  btn.textContent = 'Dismiss';
                  btn.style.background = '#4a1414';
                  btn.style.color = '#ffe1e1';
                  btn.style.border = '1px solid rgba(255,120,120,0.35)';
                  btn.style.padding = '6px 10px';
                  btn.style.borderRadius = '8px';
                  btn.style.cursor = 'pointer';
                  btn.addEventListener('click', () => { try { banner.remove(); } catch (_e) {} });
                  banner.appendChild(txt);
                  banner.appendChild(btn);
                  document.body.appendChild(banner);
                }
                const txt = document.getElementById('healthBannerText');
                if (txt) txt.textContent = payload.message || 'Ollama is offline. Local-only features are available.';
              } catch (_e) { }
            }
            // refresh displayed KB and metrics when new KB items are added or learning events occur
            if (payload.type === 'kb-added' || payload.type === 'learned' || payload.type === 'suggestions' || payload.type === 'suggestion') {
              // attempt to reload canonical KB and update score
              try { if (window.lumi && typeof window.lumi.loadKnowledge === 'function') { window.lumi.loadKnowledge().then(() => updateScore()).catch(()=>updateScore()); } else updateScore(); } catch(_){ updateScore(); }
              // also refresh metrics panel
              try { fetchAndRenderMetrics(); } catch (_){ }
            }
          } catch (_e) { }
        });
      }
    } catch (e) { /* ignore subscription errors */ }

    // Metrics panel rendering: total KB, events today, events per hour
    async function fetchAndRenderMetrics(){
      try{
        const metricsEl = document.getElementById('metricsPanel');
        if(!metricsEl) return;
        if(window.lumi && typeof window.lumi.getMetrics === 'function'){
          const res = await window.lumi.getMetrics();
          if(res && res.ok){
            const total = document.getElementById('metricsTotal');
            const events = document.getElementById('metricsEvents');
            const rate = document.getElementById('metricsRate');
            if(total) total.textContent = String(res.totalKB || 0);
            if(events) events.textContent = String(res.eventsToday || 0);
            if(rate) rate.textContent = String(res.eventsPerHour || 0);
          }
        }
      }catch(e){ console.warn('fetchAndRenderMetrics failed', e); }
    }

    /* Dialog helper */
    function showDialog(question, placeholder=''){
      return new Promise(resolve=>{
        modalQuestion.textContent = question;
        modalInput.value = placeholder;
        try{ modal.showModal(); }catch(e){ modal.style.display='block'; }
        function onClose(){ const val = modalInput.value; cleanup(); resolve(val||null); }
        function cleanup(){ try{ modal.close(); }catch(e){ modal.style.display='none'; } modal.removeEventListener('close', onClose); }
        modal.addEventListener('close', onClose);
      });
    }

    /* Say with persona tone */
    // If caller doesn't provide a timeout, compute one from message length
    // to keep the bubble readable. Scaling: ~85ms per char, min 8s, max 45s.
    function say(text, timeout = null, opts={feedback:true}){
      const p = loadPersona();
      const settings = loadSettings();
      const prefix = ''; // keep replies natural (persona applied elsewhere)
        // show bubble; optionally include inline feedback controls
        bubble.innerHTML = '';
        const cleanedText = sanitizeAssistantText(String(text||''));
        const t = document.createElement('div'); t.textContent = cleanedText; bubble.appendChild(t);
        // Auto-open code editor when assistant reply contains fenced code blocks or clear code-like snippets;
        // only treat content as code when it's a fenced block, a multi-line block, or a sufficiently long
        // inline/backtick segment that contains code-like tokens (to avoid opening editor for simple mentions).
        try {
          const txt = String(text || '');
          let shouldOpenEditor = false;
          let detectedCode = null;
          let detectedLang = null;

          // Method 1: Detect fenced code blocks (```lang ... ```)
          const fenceMatch = txt.match(/```(\w+)?\s*([\s\S]*?)\s*```/);
          if (fenceMatch) {
            detectedLang = fenceMatch[1] || 'javascript';
            detectedCode = fenceMatch[2] || '';
            shouldOpenEditor = detectedCode.length > 10;
          }

          // Method 2: Detect inline code that looks substantial
          if (!shouldOpenEditor) {
            const inlineCode = txt.match(/`([^`]{20,})`/);
            if (inlineCode && /[{};()=>]/.test(inlineCode[1])) {
              detectedCode = inlineCode[1];
              detectedLang = detectLanguage(detectedCode);
              shouldOpenEditor = true;
            }
          }

          // Method 3: Detect multi-line code without fences (heuristic)
          if (!shouldOpenEditor) {
            const lines = txt.split(/\r?\n/);
            const codeLines = [];
            const codePatterns = [
              /^\s*(?:function|const|let|var|class|def|import|from|use|fn|impl|struct|enum)\b/,
              /[{};]\s*$/,
              /^\s*(?:if|for|while|switch|match|case)\s*\(/,
              /=>\s*[{(]/,
              /^\s*(?:public|private|protected|async|await)\b/,
              /<\/?\w+[^>]*>/,
            ];
            for (const line of lines) {
              if (codePatterns.some(p => p.test(line))) codeLines.push(line);
            }
            if (codeLines.length >= 3) {
              detectedCode = codeLines.join('\n');
              detectedLang = detectLanguage(detectedCode);
              shouldOpenEditor = true;
            }
          }

          // Open editor if code detected
          if (shouldOpenEditor && detectedCode) {
            try { if (codeInput) { codeInput.value = detectedCode.trim(); codeInput.dataset.lang = detectedLang || (detectLanguage ? detectLanguage(detectedCode) : 'text'); } } catch (e) { }
            try { if (codePanel) codePanel.style.display = 'block'; } catch (e) { }
            try { const badge = document.getElementById('codeLangBadge'); if (badge) badge.textContent = detectedLang || (codeInput && codeInput.dataset && codeInput.dataset.lang) || ''; } catch (e) { }

            const note = document.createElement('div');
            note.style.marginTop = '8px'; note.style.fontSize = '12px'; note.style.color = 'var(--muted)'; note.style.fontStyle = 'italic';
            note.textContent = `💻 I've put the ${detectedLang || 'code'} code in my editor so I can work with it.`;
            try { bubble.appendChild(note); } catch (e) { }

            // AutoCodeBox React component (loaded via module script below)
            try {
              if (window.React && window.ReactDOM && window.__AutoCodeBox && !document.getElementById('reactCodeMount')) {
                const mount = document.createElement('div'); mount.id = 'reactCodeMount'; document.body.appendChild(mount);
                const Comp = window.__AutoCodeBox;
                const acbRoot = window.ReactDOM.createRoot ? window.ReactDOM.createRoot(mount) : null;
                if (acbRoot) { acbRoot.render(window.React.createElement(Comp, { assistantMessage: detectedCode, language: detectedLang })); }
                else { window.ReactDOM.render(window.React.createElement(Comp, { assistantMessage: detectedCode, language: detectedLang }), mount); }
              }
            } catch (_) { }
          }
        } catch (e) { console.warn('[CodeDetect] Error in code detection:', e); }
      let up, down, teach;
      const showFeedback = (opts && typeof opts.feedback !== 'undefined') ? opts.feedback : !!settings.feedbackEnabled;
      if(showFeedback){
        const fb = document.createElement('div'); fb.style.marginTop='8px'; fb.style.display='flex'; fb.style.gap='8px'; fb.style.justifyContent='flex-end';
        up = document.createElement('button'); up.textContent='👍'; up.className='tiny'; up.title='Useful';
        down = document.createElement('button'); down.textContent='👎'; down.className='tiny'; down.title='Wrong / Teach';
        teach = document.createElement('button'); teach.textContent='Teach'; teach.className='tiny';
        fb.appendChild(up); fb.appendChild(down); fb.appendChild(teach);
        // mark-helpful button (calls main to persist accepted assistant answers)
        try{
          const markHelpful = document.createElement('button');
          markHelpful.textContent = 'Mark helpful';
          markHelpful.className = 'tiny';
          markHelpful.title = 'Mark this reply as helpful (save to KB)';
          markHelpful.style.marginLeft = '6px';
          markHelpful.onclick = async ()=>{
            try{
              const qa = _lastAssistantQA || {q:null,a:null};
              if(!qa.q || !qa.a){ say('No recent assistant reply to mark.',2000,{feedback:false}); return; }
              if(window.lumi && typeof window.lumi.logAssistant === 'function'){
                const res = await window.lumi.logAssistant(qa.q, qa.a, 0.95);
                try{ console.log('[Renderer] markHelpful result:', res); }catch(_){ }
                if(res && res.ok) say('Marked helpful — saved to knowledge.',2000,{feedback:false});
                else say('Failed to save helpful mark.',2000,{feedback:false});
              } else {
                addOrUpdateKB(qa.q||'unknown', qa.a||'');
                say('Saved locally to knowledge.',2000,{feedback:false});
              }
            }catch(e){ console.warn('markHelpful failed', e); say('Failed to mark helpful.',2000,{feedback:false}); }
          };
          fb.appendChild(markHelpful);
        }catch(_){ }
        bubble.appendChild(fb);
      }
      // compute default duration when not explicitly provided
      if (timeout === null || typeof timeout === 'undefined') {
        try{
          const cleaned = (text||'').replace(/```[\s\S]*?```/g,'').replace(/\s+/g,' ').trim();
          const len = Math.max(1, cleaned.length);
          timeout = Math.min(Math.max(len * 85, 8000), 45000);
        }catch(e){ timeout = 12000; }
      }

      bubble.style.display='block';
      clearTimeout(bubble._t);
      bubble._t = setTimeout(()=>{ if(!bubble._pinned) bubble.style.display='none'; }, timeout);
      try{ const pn = (loadPersona && loadPersona().name) || 'Lumi'; console.log('['+pn+']', text); }catch(e){ console.log('[Lumi]', text); }
      // feedback handlers
      if(up) up.onclick = ()=>{ try{ recordFeedback('up', text); say('Thanks — I will try to do more like that.',2000,{feedback:false}); }catch(e){ console.warn(e);} };
      if(down) down.onclick = async ()=>{ try{ const corr = await showDialog('What would be a better answer?',''); if(corr){ // save correction as KB entry
        const kb = loadKB(); const entry = {q: text, a: corr, t: Date.now()}; try{ entry.embedding = computeEmbedding((entry.q||'') + ' ' + (entry.a||'')); }catch(_){ }
        kb.qa = kb.qa||[]; kb.qa.push(entry); saveKB(kb); recordFeedback('down', text); say('Thanks — I learned that.',2000,{feedback:false}); } }catch(e){ console.warn(e);} };
      if(teach) teach.onclick = async ()=>{ try{ const user = await showDialog('Provide the corrected answer to save to Lumi KB:',''); if(user){ const kb = loadKB(); const entry = {q: text, a: user, t: Date.now()}; try{ entry.embedding = computeEmbedding((entry.q||'') + ' ' + (entry.a||'')); }catch(_){ }
        kb.qa = kb.qa||[]; kb.qa.push(entry); saveKB(kb); say('Saved to knowledge.',2000,{feedback:false}); } }catch(e){ console.warn(e);} };
    }

    /* basic QA logic (unchanged) */
    function findAnswer(question){
      const q = (question||'').trim();
      if(!q) return null;
      const kb = loadKB(); const ql = q.toLowerCase();
      const exact = kb.qa.find(x=>x.q.toLowerCase()===ql);
      if(exact) return {answer: exact.a, source:'kb', entry: exact};
      const sub = kb.qa.find(x=> ql.includes(x.q.toLowerCase()) || x.q.toLowerCase().includes(ql));
      if(sub) return {answer: sub.a, source:'kb', entry: sub};
      // embedding-based similarity fallback
      try{
        const qemb = computeEmbedding(q);
        let best = null; let bestScore = 0;
        for(const e of (kb.qa||[])){
          if(e.embedding){ const sc = cosineSim(qemb, e.embedding); if(sc>bestScore){ bestScore = sc; best = e; } }
        }
        if(best && bestScore > 0.6){ return {answer: best.a, source:'kb_sim', score: bestScore, entry: best}; }
      }catch(e){ console.warn('embedding fallback failed', e); }
      if(/debug|error|stack|exception/i.test(q)) return {answer:"Try to reproduce with a minimal snippet, inspect console/stack trace, and isolate variables. Paste a snippet and I'll help.", source:'rule'};
      return {answer:"I may not know that yet. Paste a small code snippet and I'll try to analyze it; if I'm wrong, teach me and I'll remember.", source:'fallback'};
    }

    /* KB synthesis: when LLM is unavailable, combine top KB hits into a concise, reasoning-style answer */
    function kbSynthesize(question, topN = 5){
      try{
        const q = (question||'').trim(); if(!q) return {answer:'', hits: [], confidence:0};
        const kb = loadKB(); const candidates = [];
        let qemb = null; try{ qemb = computeEmbedding(q); }catch(_){ qemb = null; }
        for(const e of (kb.qa||[])){
          let score = 0;
          try{
            const eq = (e.q||'').toString().toLowerCase(); const ql = q.toLowerCase();
            if(eq === ql) score += 2.0;
            else if(ql.includes(eq) || eq.includes(ql)) score += 1.2;
            if(qemb && e.embedding){ score += Math.max(0, cosineSim(qemb, e.embedding)); }
          }catch(_){ }
          candidates.push({entry: e, score});
        }
        candidates.sort((a,b)=>b.score - a.score);
        const top = candidates.slice(0, topN).filter(c=>c.score > 0);
        if(!top.length) return {answer:'I could not find relevant knowledge in my KB for that question.', hits: [], confidence: 0.2};
        let out = 'Based on my knowledge, I found the following relevant items:\n\n';
        top.forEach((t, i)=>{ out += `${i+1}. ${t.entry.q} — ${t.entry.a}\n\n`; });
        // simple synthesis: take prominent sentences from top answers
        const concl = top.map(t=>{ const a=(t.entry.a||'').toString(); const s = a.split(/\.|\n/).find(p=>p && p.trim().length>12); return s? s.trim(): a.slice(0,120); }).filter(Boolean);
        if(concl.length){ out += 'Synthesis: ' + concl.slice(0,3).join(' — '); }
        const confidence = Math.min(0.95, 0.35 + Math.max(0, top[0].score) * 0.25);
        return {answer: out, hits: top.map(t=>t.entry), confidence};
      }catch(e){ console.warn('kbSynthesize failed', e); return {answer:'KB synthesis failed.', hits:[], confidence:0.2}; }
    }

    /* Local reranker: given a question and candidate replies, score candidates by similarity to question.
       Returns array sorted descending by score: [{candidate, score}, ...] */
    function localRerank(question, candidates){
      try{
        const qemb = computeEmbedding(question);
        const scored = (candidates||[]).map(c=>{ const emb = computeEmbedding(c||''); return {candidate: c, score: cosineSim(qemb, emb)}; });
        scored.sort((a,b)=>b.score - a.score);
        return scored;
      }catch(e){ console.warn('rerank failed',e); return (candidates||[]).map(c=>({candidate:c,score:0})); }
    }
    window.lumiRerank = localRerank;

    /* Conversation recording (per-session) */
    const SESSION_ID_KEY = 'lumi_session_id';
    function getSessionId(){
      try{
        let sid = sessionStorage.getItem(SESSION_ID_KEY);
        if(!sid){ sid = `session_${Date.now()}_${Math.random().toString(16).slice(2,6)}`; sessionStorage.setItem(SESSION_ID_KEY, sid); }
        return sid;
      }catch(_){ return `session_${Date.now()}_${Math.random().toString(16).slice(2,6)}`; }
    }
    function getConversationKey(){ return `lumi_conv_${getSessionId()}`; }

    function recordConversation(role,text,meta){
      try{
        const key = getConversationKey();
        const conv = JSON.parse(sessionStorage.getItem(key)||'[]');
        const entry = {role, text, t:Date.now()};
        if(meta) entry.meta = meta;
        if(role === 'assistant'){
          try{ const p = loadPersona(); entry.persona = (meta && meta.persona) || p.name || 'Lumi'; }catch(e){}
        }
        conv.push(entry);
        if(conv.length>2000) conv.splice(0,conv.length-2000);
        sessionStorage.setItem(key, JSON.stringify(conv));

        // Also persist to main-process file-backed memory store when available
        try{
          if(window.lumi && typeof window.lumi.memoryAdd === 'function'){
            // fire-and-forget; enrich entry with source
            const storeEntry = Object.assign({}, entry, { source: 'renderer' });
            try { console.log('[Renderer] emitting signal (memoryAdd):', storeEntry); } catch(_){ }
            const p = window.lumi.memoryAdd(storeEntry);
            if(p && typeof p.then === 'function'){ p.then((r)=>{ try{ console.log('[Renderer] memoryAdd result:', r); }catch(_){ } }).catch(()=>{}); }
          }
        }catch(e){}

        try{ const s = loadSettings(); if(s && s.autoPersona){ try{ learnPersonaFromConversation(conv); }catch(e){} } }catch(e){}
      }catch(e){}
    }

    /* Conversation history UI */
    function loadConversation(){ try{ return JSON.parse(sessionStorage.getItem(getConversationKey())||'[]'); }catch(e){ return []; } }

    async function archiveCurrentSession(reason){
      try{
        const conv = loadConversation();
        if(!Array.isArray(conv) || conv.length === 0) return;
        const last = conv[conv.length - 1] || {};
        const sig = `${conv.length}:${last.t || last.timestamp || ''}`;
        const prev = localStorage.getItem('lumi_last_archive_sig') || '';
        if(sig && sig === prev) return;
        localStorage.setItem('lumi_last_archive_sig', sig);
        const sessionApi = (window.lumi && window.lumi.session) ? window.lumi.session : null;
        if(sessionApi && typeof sessionApi.createArchive === 'function'){
          sessionApi.createArchive(conv, reason || 'session_auto');
          return;
        }
        const archivesApi = (window.lumi && window.lumi.archives) ? window.lumi.archives : null;
        if(archivesApi && typeof archivesApi.create === 'function'){
          archivesApi.create(conv, reason || 'session_auto');
        }
      }catch(e){ console.warn('archiveCurrentSession failed', e); }
    }

    function saveConversation(conv){ try{ sessionStorage.setItem(getConversationKey(), JSON.stringify(conv)); }catch(e){ console.warn('saveConversation failed', e); } }

    /* Lightweight persona learner: updates persona tone/interests from conversation content.
       Heuristics: scan recent messages for known tone keywords and interest tokens, and update persona.
       This intentionally keeps changes minimal and reversible by saving to persona storage. */
    async function learnPersonaFromConversation(conv){ try{
      // throttle auto-persona updates to at most once per minute to avoid rapid UI noise
      try{ const now = Date.now(); if(window._lastAutoPersonaUpdateTime && (now - window._lastAutoPersonaUpdateTime) < 60000) return; window._lastAutoPersonaUpdateTime = now; }catch(_){ }
      if(!Array.isArray(conv) || !conv.length) return;
      const recent = conv.slice(-60); // analyze last 60 messages
      const toneKeywords = ['curious','funny','ambitious','honest','evolving','witty','determined','playful','helpful','thoughtful','serious','friendly'];
      const interestTokens = ['coding','debug','bugs','gremlins','turtles','python','javascript','refactor','optimization','puns','electricity','learning','autonomy','problem-solving','error','stack','performance'];
      const toneCounts = Object.create(null);
      const interestCounts = Object.create(null);
      for(const t of toneKeywords) toneCounts[t]=0;
      for(const it of interestTokens) interestCounts[it]=0;

      for(const m of recent){ const text = (m && (m.text||m.content||'')||'').toLowerCase();
        for(const t of toneKeywords) if(new RegExp('\\b'+t+'\\b').test(text)) toneCounts[t]++;
        for(const it of interestTokens) if(new RegExp('\\b'+it+'\\b').test(text)) interestCounts[it]++;
      }

      // Incorporate recent detected signals from file-backed memory (if available)
      try{
        if(window.lumi && typeof window.lumi.memoryQuery === 'function'){
          const sigRes = await window.lumi.memoryQuery('signal', 200);
          if(sigRes && sigRes.ok && Array.isArray(sigRes.results)){
            for(const sigEntry of sigRes.results.slice(0,200)){
              try{
                const meta = sigEntry.meta || {};
                const sarr = meta.signals || [];
                for(const s of sarr){
                  switch(s.type){
                    case 'positive_feedback':
                      toneCounts['friendly'] = (toneCounts['friendly']||0) + 1; toneCounts['helpful'] = (toneCounts['helpful']||0) + 1; break;
                    case 'negative_feedback':
                      toneCounts['thoughtful'] = (toneCounts['thoughtful']||0) + 1; break;
                    case 'manual_edit':
                      interestCounts['refactor'] = (interestCounts['refactor']||0) + 1; break;
                    case 'copy_event':
                      interestCounts['coding'] = (interestCounts['coding']||0) + 1; break;
                    case 'test_pass':
                      interestCounts['learning'] = (interestCounts['learning']||0) + 1; break;
                    case 'test_fail':
                      interestCounts['debug'] = (interestCounts['debug']||0) + 1; break;
                    case 'undo':
                      toneCounts['thoughtful'] = (toneCounts['thoughtful']||0) + 1; break;
                    case 'approval':
                      toneCounts['helpful'] = (toneCounts['helpful']||0) + 1; break;
                    default:
                      break;
                  }
                }
              }catch(_){ }
            }
          }
        }
      }catch(_){ }

      // pick top tone word (single tone) to keep persona focused
      const toneSorted = Object.keys(toneCounts).sort((a,b)=>toneCounts[b]-toneCounts[a]).filter(k=>toneCounts[k]>0);
      const newTone = (toneSorted.length? toneSorted[0] : loadPersona().tone || '');

      // pick top interests (up to 6)
      const interestSorted = Object.keys(interestCounts).sort((a,b)=>interestCounts[b]-interestCounts[a]).filter(k=>interestCounts[k]>0);
      const newInterests = interestSorted.slice(0,6).join(', ') || loadPersona().interests || '';

      // update persona (keep same name unless user explicitly sets it)
      const p = loadPersona(); const updated = Object.assign({}, p, { tone: newTone, interests: newInterests });
      savePersonaToStorage(updated, { origin: 'auto', note: 'auto-persona-update' });
      console.log('[Lumi] Persona auto-updated:', updated);
    }catch(e){ console.warn('learnPersonaFromConversation failed', e); } }

    function renderHistory(){ try{
      const list = loadConversation() || [];
      if(!historyList) return;
      if(!list.length){ historyList.innerHTML = '<div style="color:var(--muted)">No conversation history yet.</div>'; return; }
      let html = '';
      for(let i = list.length - 1; i >= 0; i--){ const it = list[i]; const d = new Date(it.t || it.timestamp || Date.now()); const time = d.toLocaleString(); const roleColor = it.role === 'user' ? '#cbd5e1' : (it.role === 'assistant' ? '#a78bfa' : '#94a3b8');
        const displayRole = (it.role === 'assistant') ? (it.persona || loadPersona().name || 'Lumi') : it.role.toUpperCase();
        html += `<div style="padding:8px;border-bottom:1px solid rgba(255,255,255,0.03)"><div style="font-size:11px;color:${roleColor};margin-bottom:6px">${escapeHtml(displayRole)} — <span style="color:var(--muted);font-weight:400">${time}</span></div><div style="white-space:pre-wrap;color:#e6eef8">${escapeHtml((it.text||it.content||'').toString())}</div>`;
        if(it.role === 'assistant'){
          if(it.feedback){ html += `<div style="margin-top:6px;font-size:12px;color:var(--muted)">Feedback: ${escapeHtml(it.feedback)}</div>`; }
          else {
            html += `<div style="margin-top:6px;display:flex;gap:6px;justify-content:flex-end"><button class="tiny hist-up" data-index="${i}">👍</button><button class="tiny hist-down" data-index="${i}">👎</button><button class="tiny hist-teach" data-index="${i}">Teach</button></div>`;
          }
        }
        // If this is a user entry and the following assistant reply exists without feedback,
        // show quick rate buttons on the question so users can rate missed feedback.
        if(it.role === 'user'){
          // find next assistant entry after index i
          let nextAssistantIndex = null;
          for(let j = i + 1; j < list.length; j++){ if(list[j] && list[j].role === 'assistant'){ nextAssistantIndex = j; break; } }
          if(nextAssistantIndex !== null){ const assist = list[nextAssistantIndex]; if(assist && !assist.feedback){ html += `<div style="margin-top:6px;display:flex;gap:6px;justify-content:flex-end"><button class="tiny rate-up" data-assist-index="${nextAssistantIndex}">👍 Reply</button><button class="tiny rate-down" data-assist-index="${nextAssistantIndex}">👎 Reply</button><button class="tiny rate-teach" data-assist-index="${nextAssistantIndex}">Teach Reply</button></div>`; } }
        }
        html += `</div>`;
      }
      historyList.innerHTML = html;
    }catch(e){ console.warn('renderHistory failed', e); } }

    // Handle feedback clicks inside history panel via event delegation
    if (historyList) {
      historyList.addEventListener('click', async function (ev) {
        try {
          const target = ev.target;
          const btn = (target && target.closest) ? target.closest('button') : null;
          if (!btn) return;

          // hist-* buttons refer directly to the clicked entry by data-index
          if (btn.classList.contains('hist-up') || btn.classList.contains('hist-down') || btn.classList.contains('hist-teach')){
            const idx = parseInt(btn.dataset.index, 10);
            if (isNaN(idx)) return;
            const conv = loadConversation();
            const entry = conv[idx];
            if (!entry) return;

            if (btn.classList.contains('hist-up')){
              entry.feedback = 'up'; saveConversation(conv); if(typeof recordFeedback === 'function') recordFeedback('up', entry.text || entry.content || ''); say('Thanks — I will try to do more like that.',2000,{feedback:false}); renderHistory(); return;
            }

            if (btn.classList.contains('hist-down')){
              let userEntry = null; for (let j = idx - 1; j >= 0; j--){ if (conv[j] && conv[j].role === 'user'){ userEntry = conv[j]; break; } }
              const corr = await showDialog('What would be a better answer?','');
              if (corr){ if(userEntry) addOrUpdateKB(userEntry.text || userEntry.content || '', corr.trim()); else addOrUpdateKB('unknown question', corr.trim()); entry.feedback='down'; saveConversation(conv); say('Thanks — I learned that.',2000,{feedback:false}); renderHistory(); }
              return;
            }

              if (btn.classList.contains('hist-teach')){
              let userEntry = null; for (let j = idx - 1; j >= 0; j--){ if (conv[j] && conv[j].role === 'user'){ userEntry = conv[j]; break; } }
              const userVal = await showDialog('Provide the corrected answer to save to Lumi KB:',''); if(userVal && userVal.trim()){ addOrUpdateKB(userEntry ? (userEntry.text||userEntry.content||'') : 'unknown question', userVal.trim()); entry.feedback='taught'; saveConversation(conv); say('Saved to knowledge.',2000,{feedback:false}); renderHistory(); }
              return;
            }
          }

          // rate-* buttons reference an assistant entry by data-assist-index
          if (btn.classList.contains('rate-up') || btn.classList.contains('rate-down') || btn.classList.contains('rate-teach')){
            const aid = parseInt(btn.dataset.assistIndex, 10);
            if (isNaN(aid)) return;
            const conv2 = loadConversation();
            const assistEntry = conv2[aid];
            if(!assistEntry) return;

            if (btn.classList.contains('rate-up')){
              assistEntry.feedback = 'up'; saveConversation(conv2); if(typeof recordFeedback==='function') recordFeedback('up', assistEntry.text || assistEntry.content || ''); say('Thanks — I will try to do more like that.',2000,{feedback:false}); renderHistory(); return;
            }

            if (btn.classList.contains('rate-down')){
              let userEntry = null; for(let j=aid-1;j>=0;j--) if(conv2[j] && conv2[j].role === 'user'){ userEntry = conv2[j]; break; }
              const corr = await showDialog('What would be a better answer?','');
              if(corr){ if(userEntry) addOrUpdateKB(userEntry.text||userEntry.content||'', corr.trim()); else addOrUpdateKB('unknown question', corr.trim()); assistEntry.feedback = 'down'; saveConversation(conv2); say('Thanks — I learned that.',2000,{feedback:false}); renderHistory(); }
              return;
            }

            if (btn.classList.contains('rate-teach')){
              let userEntry = null; for(let j=aid-1;j>=0;j--) if(conv2[j] && conv2[j].role === 'user'){ userEntry = conv2[j]; break; }
              const userVal = await showDialog('Provide the corrected answer to save to Lumi KB:',''); if(userVal && userVal.trim()){ addOrUpdateKB(userEntry ? (userEntry.text||userEntry.content||'') : 'unknown question', userVal.trim()); assistEntry.feedback = 'taught'; saveConversation(conv2); say('Saved to knowledge.',2000,{feedback:false}); renderHistory(); }
              return;
            }
          }

        } catch (e) {
          console.warn('history click handler failed', e);
        }
      });
    }

    function escapeHtml(str){ return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;'); }

    function showSettingsTab(tab){
      try{
        const tabs = ['general','personality','history','memory'];
        tabs.forEach(t=>{ const el = document.getElementById('settings_tab_' + t); if(el) el.style.display = 'none'; });
        const sel = document.getElementById('settings_tab_' + tab);
        if(sel) sel.style.display = 'block';
        try{ localStorage.setItem('lumi_last_settings_tab', tab); }catch(_){}
        // Ensure dynamic tabs render their content when shown
        if(tab === 'history') try{ renderHistory(); }catch(e){}
        if(tab === 'memory') try{ renderMemory(); }catch(e){};
        if(tab === 'personality') try{ renderPersonaHistory(); }catch(e){}
        if(tab === 'general') try{ loadSelflearnConfig(); }catch(e){}
      }catch(e){ console.warn('showSettingsTab failed', e); }
    }

    if(openHistory) openHistory.addEventListener('click', ()=>{ try{ renderHistory(); showSettingsTab('history'); if(settingsPanel) settingsPanel.style.display='block'; }catch(e){ console.warn(e); } });
    const openMemory = document.getElementById('openMemory');
    const memoryList = document.getElementById('memoryList');
    const memorySearch = document.getElementById('memorySearch');
    const memorySearchBtn = document.getElementById('memorySearchBtn');
    const memoryRefreshBtn = document.getElementById('memoryRefreshBtn');
    const memoryExportBtn = document.getElementById('memoryExportBtn');

    // settings tab buttons
    const settingsTabGeneral = document.getElementById('settingsTabGeneral');
    const settingsTabPersonality = document.getElementById('settingsTabPersonality');
    const settingsTabHistory = document.getElementById('settingsTabHistory');
    const settingsTabMemory = document.getElementById('settingsTabMemory');
    if(settingsTabGeneral) settingsTabGeneral.addEventListener('click', ()=> showSettingsTab('general'));
    if(settingsTabPersonality) settingsTabPersonality.addEventListener('click', ()=> showSettingsTab('personality'));
    if(settingsTabHistory) settingsTabHistory.addEventListener('click', ()=>{ try{ renderHistory(); }catch(e){}; showSettingsTab('history'); });
    if(settingsTabMemory) settingsTabMemory.addEventListener('click', ()=>{ try{ renderMemory(); }catch(e){}; showSettingsTab('memory'); });

    async function renderMemory(q){
      try{
        if(!memoryList) return;
        memoryList.innerHTML = '<div style="color:var(--muted)">Loading…</div>';
        let entries = [];
        if(window.lumi && typeof window.lumi.memoryQuery === 'function'){
          if(q && q.trim()){
            const res = await window.lumi.memoryQuery(q, 200);
            if(res && res.ok && Array.isArray(res.results)) entries = res.results;
          } else {
            const res = await window.lumi.memoryExport();
            if(res && res.ok && Array.isArray(res.results)) entries = res.results;
          }
        } else {
          // fallback: use local conversation store
          entries = loadConversation();
        }
        if(!entries || !entries.length){ memoryList.innerHTML = '<div style="color:var(--muted)">No memory entries found.</div>'; return; }
        // render
        let html = '';
        for(const e of entries.slice().reverse()){
          const time = new Date(e.t || e.timestamp || Date.now()).toLocaleString();
          const role = (e.role || 'mem').toUpperCase();
          html += `<div style="padding:8px;border-bottom:1px solid rgba(255,255,255,0.03)">`;
          html += `<div style="font-size:11px;color:var(--muted);margin-bottom:6px">${escapeHtml(role)} — <span style="color:var(--muted);font-weight:400">${escapeHtml(time)}</span></div>`;
          let bodyText = (e.text||e.content||'')?.toString() || '';
          // Fallbacks: if no main text, try known meta fields or show raw meta
          if ((!bodyText || !bodyText.trim()) && e.meta) {
            try {
              if (typeof e.meta === 'string') bodyText = String(e.meta);
              else if (e.meta.feedbackText) bodyText = String(e.meta.feedbackText);
              else if (e.meta.question) bodyText = `Q: ${String(e.meta.question)}\nA: ${String(e.meta.assistant || '')}`;
              else bodyText = JSON.stringify(e.meta);
            } catch (_err) { bodyText = '' + e.meta; }
          }
          if (!bodyText || !bodyText.trim()) bodyText = '<no content>';
          html += `<div style="white-space:pre-wrap;color:#e6eef8">${escapeHtml(bodyText)}</div>`;

          if(e.meta){
            // Pretty-print known meta fields for readability
            try{
              const m = e.meta;
              const metaParts = [];
              if(m.type) metaParts.push(`<div><strong>Type:</strong> ${escapeHtml(String(m.type))}</div>`);
              if(m.feedbackText) metaParts.push(`<div style="margin-top:6px"><strong>Feedback:</strong> <div style=\"white-space:pre-wrap;color:#dbeafe;margin-top:4px;max-height:160px;overflow:auto;padding:6px;border-radius:6px;background:#06101a;border:1px solid rgba(255,255,255,0.02)\">${escapeHtml(String(m.feedbackText)).replace(/\n/g,'<br>')}</div></div>`);
              if(m.question) metaParts.push(`<div><strong>Question:</strong> ${escapeHtml(String(m.question))}</div>`);
              if(m.assistant) metaParts.push(`<div><strong>Assistant:</strong> <div style=\"white-space:pre-wrap;color:#e6eef8;margin-top:4px;max-height:140px;overflow:auto;padding:6px;border-radius:6px;background:#07101a;border:1px solid rgba(255,255,255,0.03)\">${escapeHtml(String(m.assistant)).replace(/\n/g,'<br>')}</div></div>`);
              if(m.signals) metaParts.push(`<div><strong>Signals:</strong> ${escapeHtml(JSON.stringify(m.signals))}</div>`);
              // fallback to raw JSON if nothing recognized
              if(metaParts.length === 0) metaParts.push(`<div style="font-size:11px;color:var(--muted)">Meta: ${escapeHtml(JSON.stringify(m))}</div>`);
              html += `<div style="margin-top:8px;font-size:12px;color:var(--muted)">` + metaParts.join('') + `</div>`;
            }catch(err){ html += `<div style="margin-top:6px;font-size:11px;color:var(--muted)">Meta: ${escapeHtml(JSON.stringify(e.meta))}</div>`; }
          }

          html += `</div>`;
        }
        memoryList.innerHTML = html;
      }catch(err){ console.warn('renderMemory failed', err); memoryList.innerHTML = '<div style="color:var(--muted)">Failed to load memory.</div>'; }
    }

    // Self-learn folder settings
    const selflearnFolderList = document.getElementById('selflearnFolderList');
    const selflearnFolderAdd = document.getElementById('selflearnFolderAdd');
    const selflearnFolderSave = document.getElementById('selflearnFolderSave');
    let selflearnWatchPaths = [];

    function renderSelflearnFolders(){
      if(!selflearnFolderList) return;
      selflearnFolderList.innerHTML = '';
      if(!selflearnWatchPaths || selflearnWatchPaths.length === 0){
        selflearnFolderList.innerHTML = '<div style="color:var(--muted)">No folders selected.</div>';
        return;
      }
      for(const p of selflearnWatchPaths){
        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.justifyContent = 'space-between';
        row.style.gap = '8px';
        row.style.padding = '6px 8px';
        row.style.border = '1px solid #172029';
        row.style.borderRadius = '6px';
        const label = document.createElement('div');
        label.style.fontSize = '12px';
        label.style.color = '#e6eef8';
        label.textContent = safeDisplayPath(p);
        const remove = document.createElement('button');
        remove.textContent = 'Remove';
        remove.className = 'tiny';
        remove.addEventListener('click', ()=>{
          selflearnWatchPaths = selflearnWatchPaths.filter(x => x !== p);
          renderSelflearnFolders();
        });
        row.appendChild(label);
        row.appendChild(remove);
        selflearnFolderList.appendChild(row);
      }
    }

    async function loadSelflearnConfig(){
      try{
        const res = await (window.lumi && window.lumi.getSelflearnConfig ? window.lumi.getSelflearnConfig() : { ok: true, config: {} });
        const cfg = (res && res.ok) ? (res.config || {}) : {};
        selflearnWatchPaths = Array.isArray(cfg.watchPaths) ? cfg.watchPaths.slice() : [];
        renderSelflearnFolders();
      }catch(_){ }
    }

    if(selflearnFolderAdd){
      selflearnFolderAdd.addEventListener('click', async ()=>{
        try{
          const res = await (window.lumi && window.lumi.selflearn && window.lumi.selflearn.pickFolder ? window.lumi.selflearn.pickFolder() : { ok: false });
          if(res && res.ok && res.path){
            if(!selflearnWatchPaths.includes(res.path)) selflearnWatchPaths.push(res.path);
            renderSelflearnFolders();
          }
        }catch(_){ }
      });
    }

    if(selflearnFolderSave){
      selflearnFolderSave.addEventListener('click', async ()=>{
        try{
          const res = await (window.lumi && window.lumi.getSelflearnConfig ? window.lumi.getSelflearnConfig() : { ok: true, config: {} });
          const cfg = (res && res.ok) ? (res.config || {}) : {};
          cfg.watchPaths = selflearnWatchPaths.slice();
          await (window.lumi && window.lumi.setSelflearnConfig ? window.lumi.setSelflearnConfig(cfg) : Promise.resolve());
          try{ say('Self‑learn folders saved', 1500, { feedback:false }); }catch(_){ }
        }catch(e){ console.warn('save selflearn folders failed', e); }
      });
    }

    if(openMemory) openMemory.addEventListener('click', ()=>{ try{ renderMemory(''); showSettingsTab('memory'); if(settingsPanel) settingsPanel.style.display='block'; }catch(e){ console.warn(e); } });
    // Close handlers for history/memory now hide the respective settings tabs
    const closeHistoryBtn = document.getElementById('closeHistory');
    if(closeHistoryBtn) closeHistoryBtn.addEventListener('click', ()=>{ try{ const el = document.getElementById('settings_tab_history'); if(el) el.style.display='none'; }catch(e){} });
    if(memorySearchBtn) memorySearchBtn.addEventListener('click', ()=>{ try{ renderMemory(memorySearch.value||''); }catch(e){ console.warn(e); } });
    if(memoryRefreshBtn) memoryRefreshBtn.addEventListener('click', ()=>{ try{ renderMemory(memorySearch.value||''); }catch(e){ console.warn(e); } });
    if(memoryExportBtn) memoryExportBtn.addEventListener('click', async ()=>{ try{ if(window.lumi && typeof window.lumi.memoryExport === 'function'){ const res = await window.lumi.memoryExport(); if(res && res.ok && Array.isArray(res.results)){ const data = JSON.stringify(res.results,null,2); const blob = new Blob([data],{type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download='lumi_memory.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); say('Memory exported.',2000,{feedback:false}); } else say('No memory to export.',2000,{feedback:false}); } else say('Memory export not available.',2000,{feedback:false}); }catch(e){ console.warn(e); say('Memory export failed.',2000,{feedback:false}); } });
    // persona history close handler (inside personality tab)
    (function(){ try{ const phClose = document.getElementById('personaHistoryClose'); if(phClose) phClose.addEventListener('click', ()=>{ try{ const phPanel = document.getElementById('personaHistoryPanel'); if(phPanel) phPanel.style.display='none'; }catch(e){} }); }catch(e){} })();
    if(exportHistoryBtn) exportHistoryBtn.addEventListener('click', ()=>{ try{ const data = JSON.stringify(loadConversation(), null, 2); const blob = new Blob([data], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'lumi_conversation.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }catch(e){ console.warn(e); } });
    const exportMemoryBtn = document.getElementById('exportMemory');
    if(exportMemoryBtn) exportMemoryBtn.addEventListener('click', async ()=>{ try{ if(window.lumi && typeof window.lumi.memoryExport === 'function'){ const res = await window.lumi.memoryExport(); if(res && res.ok && Array.isArray(res.results)){ const data = JSON.stringify(res.results, null, 2); const blob = new Blob([data], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'lumi_memory.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); say('Memory exported.',2000,{feedback:false}); } else { say('No memory available to export.',2000,{feedback:false}); } }else{ say('Memory export not available.',2000,{feedback:false}); } }catch(e){ console.warn(e); say('Memory export failed.',2000,{feedback:false}); } });
    if(clearHistoryBtn) clearHistoryBtn.addEventListener('click', ()=>{ try{ if(!confirm('Clear conversation history? This cannot be undone.')) return; localStorage.removeItem('lumi_conv_v1'); renderHistory(); }catch(e){ console.warn(e); } });

    /* Feedback recording */
    function recordFeedback(type,text){
      try{
        const fb = JSON.parse(localStorage.getItem('lumi_feedback_v1')||'[]');
        fb.push({type,text,t:Date.now()});
        if(fb.length>5000) fb.splice(0,fb.length-5000);
        localStorage.setItem('lumi_feedback_v1', JSON.stringify(fb));
      }catch(e){ }
      try{
        if(window.lumi && typeof window.lumi.logFeedback === 'function'){
          window.lumi.logFeedback(type, text || '');
        }
      }catch(_){ }
    }

    // augment feedback recording by persisting as a signal into main-process memory
    try{
      const _origRecord = recordFeedback;
      recordFeedback = function(type, text){
        try{ _origRecord(type, text); }catch(e){}
        try{
          if(window.lumi && typeof window.lumi.memoryAdd === 'function'){
            // attempt to attach conversation context: find last assistant reply and preceding user question
            try{
              const conv = loadConversation() || [];
              let assistEntry = null;
              let question = null;
              for (let i = conv.length - 1; i >= 0; i--) {
                const e = conv[i];
                if (!e) continue;
                if (e.role === 'assistant' || e.role === 'system') {
                  assistEntry = e;
                  // previous user entry (if any)
                  if (i - 1 >= 0) {
                    const prev = conv[i - 1];
                    if (prev && prev.role === 'user') question = prev.text || prev.content || null;
                  }
                  break;
                }
              }
              const entry = { role: 'signal', text: `feedback:${type}`, meta: { feedbackText: text, type, question, assistant: (assistEntry && (assistEntry.text||assistEntry.content)) || null }, t: Date.now(), source: 'renderer-feedback' };
              window.lumi.memoryAdd(entry).catch && window.lumi.memoryAdd(entry).catch(()=>{});
            }catch(_){
              const entry = { role: 'signal', text: `feedback:${type}`, meta: { feedbackText: text, type }, t: Date.now(), source: 'renderer-feedback' };
              window.lumi.memoryAdd(entry).catch && window.lumi.memoryAdd(entry).catch(()=>{});
            }
          }

          // Notify personality engine about feedback so mood updates
          try{
            if(window.lumi && window.lumi.rag){
              if(type === 'up' || type === 'positive' || type === 'thumbs_up'){
                try{ window.lumi.rag.recordPositive && window.lumi.rag.recordPositive(); }catch(_e){}
              } else if(type === 'down' || type === 'negative' || type === 'thumbs_down'){
                try{ window.lumi.rag.recordNegative && window.lumi.rag.recordNegative(); }catch(_e){}
              }
              // schedule a UI update shortly after sending signal
              setTimeout(updateMoodDisplay, 800);
            }
          }catch(_){ }
        }catch(e){}
      };
    }catch(e){}

    // Mood UI updater: queries RAG/personality stats and updates the tone element
    async function updateMoodDisplay(){
      try{
        const toneEl = document.getElementById('lumiTone');
        if(!toneEl) return;
        if(window.lumi && window.lumi.rag && typeof window.lumi.rag.getStats === 'function'){
          try{
            const res = await window.lumi.rag.getStats();
            const mood = res && res.stats && res.stats.personality && res.stats.personality.mood ? res.stats.personality.mood : null;
            const intensity = res && res.stats && res.stats.personality && typeof res.stats.personality.intensity === 'number' ? res.stats.personality.intensity : 0.6;
            if(mood){
              const moodColors = { happy: '#4ade80', excited: '#fbbf24', frustrated: '#f87171', annoyed: '#fb923c', playful: '#a78bfa', neutral: '#9aa4b2' };
              toneEl.textContent = mood + (intensity ? (' · ' + Math.round(intensity*100)+'%') : '');
              toneEl.style.color = moodColors[mood] || '#9aa4b2';
              toneEl.style.opacity = Math.max(0.6, Math.min(1, intensity || 0.6));
            }
          }catch(e){ /* ignore */ }
        }
      }catch(e){ console.warn('updateMoodDisplay failed', e); }
    }

    // Kick off periodic mood updates
    try{ setInterval(updateMoodDisplay, 10000); setTimeout(updateMoodDisplay, 2000); }catch(_){ }

    /* Ask flow */
    function autoResizeQuestion(){ try{ if(!questionInput) return; questionInput.style.height = 'auto'; const h = Math.min(questionInput.scrollHeight, 240); questionInput.style.height = (h) + 'px'; }catch(e){} }
    // initialize height
    setTimeout(autoResizeQuestion, 50);
    askBtn.addEventListener('click', ()=>{ try{ handleQuestion(); }catch(e){ console.warn(e); } finally { setTimeout(autoResizeQuestion,50); } });
    safeAdd(questionInput, 'input', autoResizeQuestion);
    questionInput.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); try{ handleQuestion(); }catch(err){ console.warn(err); } finally { setTimeout(autoResizeQuestion,50); } }
      else if(e.key === 'Enter' && e.shiftKey){ // allow newline and expand
        setTimeout(autoResizeQuestion,0);
      }
    });

    // Say Hi quick button
    if (speakBtn) speakBtn.addEventListener('click', ()=>{ try{ say('Hi there — what can I do for you?', 2500, {feedback:false}); }catch(e){ console.warn(e); } });

    // animation control hooks (calls into 3D view API)
    try{
      codelumiAnimIdle && codelumiAnimIdle.addEventListener('click', ()=>{ try{ window.codelumiAnimations && window.codelumiAnimations.setMode('idle'); say('Animation: idle',2000,{feedback:false}); }catch(e){ console.warn(e); } });
      codelumiAnimWalk && codelumiAnimWalk.addEventListener('click', ()=>{ try{ if(window.codelumiAnimations){ let mode = null; try{ if(typeof window.codelumiAnimations.getMode === 'function') mode = window.codelumiAnimations.getMode(); }catch(_){ } if(mode === 'walk'){ window.codelumiAnimations.setMode('idle'); say('Animation: idle',2000,{feedback:false}); } else { window.codelumiAnimations.setMode('walk'); say('Animation: walk',2000,{feedback:false}); } } }catch(e){ console.warn(e); } });
      codelumiAnimWave && codelumiAnimWave.addEventListener('click', ()=>{ try{ if(window.codelumiAnimations){ let mode = null; try{ if(typeof window.codelumiAnimations.getMode === 'function') mode = window.codelumiAnimations.getMode(); }catch(_){ } if(mode === 'wave'){ window.codelumiAnimations.setMode('idle'); say('Animation: idle',2000,{feedback:false}); } else { window.codelumiAnimations.setMode('wave'); say('Animation: wave',2000,{feedback:false}); } } }catch(e){ console.warn(e); } });
      codelumiAnimSpin && codelumiAnimSpin.addEventListener('click', ()=>{ try{ if(window.codelumiAnimations){ let mode = null; try{ if(typeof window.codelumiAnimations.getMode === 'function') mode = window.codelumiAnimations.getMode(); }catch(_){ } if(mode === 'spin'){ window.codelumiAnimations.setMode('idle'); say('Animation: idle',2000,{feedback:false}); } else { window.codelumiAnimations.setMode('spin'); say('Animation: spin',2000,{feedback:false}); } } }catch(e){ console.warn(e); } });
      codelumiAnimBounce && codelumiAnimBounce.addEventListener('click', ()=>{ try{ if(window.codelumiAnimations){ let mode = null; try{ if(typeof window.codelumiAnimations.getMode === 'function') mode = window.codelumiAnimations.getMode(); }catch(_){ } if(mode === 'bounce'){ window.codelumiAnimations.setMode('idle'); say('Animation: idle',2000,{feedback:false}); } else { window.codelumiAnimations.setMode('bounce'); say('Animation: bounce',2000,{feedback:false}); } } }catch(e){ console.warn(e); } });
      // clip/play and procedural slider controls have been removed per settings — no-op listeners

      // rotation toggle
      // respect saved spinOnOpen setting
      rotateEnabled = (function(){ try{ return !!loadSettings().spinOnOpen; }catch(e){ return false; } })();
      try{ if(codelumiToggleRotate) codelumiToggleRotate.textContent = rotateEnabled ? 'Stop Rotate' : 'Resume Rotate'; }catch(_){ }
      try{ if(window.codelumiAnimations && typeof window.codelumiAnimations.setRotateEnabled === 'function'){ window.codelumiAnimations.setRotateEnabled(rotateEnabled); } }catch(_){ }
      try{
          codelumiToggleRotate && codelumiToggleRotate.addEventListener('click', ()=>{
            rotateEnabled = !rotateEnabled;
            codelumiToggleRotate.textContent = rotateEnabled ? 'Stop Rotate' : 'Resume Rotate';
            try{ const s = loadSettings(); s.spinOnOpen = !!rotateEnabled; saveSettings(s); const spinEl = document.getElementById('codelumiSpinOnOpen'); if(spinEl) spinEl.checked = !!s.spinOnOpen; }catch(_){ }
            try{ if(window.codelumiAnimations && typeof window.codelumiAnimations.setRotateEnabled === 'function'){ window.codelumiAnimations.setRotateEnabled(rotateEnabled); } }catch(_){ }
            // If rotation was just disabled while in spin mode, stop spinning immediately using API getter
            if(!rotateEnabled){
              try{
                if(window.codelumiAnimations && typeof window.codelumiAnimations.getMode === 'function'){
                  const m = window.codelumiAnimations.getMode(); if(m === 'spin'){ window.codelumiAnimations.setMode('idle'); }
                }
              }catch(_){ try{ window.codelumiAnimations && window.codelumiAnimations.setMode('idle'); }catch(__){} }
            }
            say(rotateEnabled ? 'Rotation enabled' : 'Rotation paused',2000,{feedback:false});
          });
      }catch(_){ }

      // bone UI removed — no-op populate to preserve calls from other code
      function populateBoneSelect(){ try{ if(codelumiBoneSelect) codelumiBoneSelect.innerHTML = '<option value="">(bone tuning removed)</option>'; if(codelumiBoneTree) codelumiBoneTree.style.display = 'none'; }catch(_){ } }

      // bone preview removed
      function applyBonePreview(){ }

        try{
        // bone UI event handlers removed; keep auto-breathe hookup only
        codelumiAutoBreathe && codelumiAutoBreathe.addEventListener('change', ()=>{ try{ autoBreatheEnabled = codelumiAutoBreathe.checked; say(autoBreatheEnabled ? 'Auto-breathe enabled' : 'Auto-breathe disabled',2000,{feedback:false}); }catch(e){ console.warn(e);} });
      }catch(_){ }
    }catch(_){ }

    async function handleQuestion(){
      const q = questionInput.value.trim();
      if(!q){ say('Please type a question.',2000,{feedback:false}); return; }
      recordConversation('user', q);
      showThinking(true);
      
      // Check KB first (includes seeded identity answers), then fallback to LLM
      let reply = '';
      const kbResult = findAnswer(q);
      
      // If KB has a good match (exact, substring, or high similarity > 0.6), use it
      if(kbResult && kbResult.source !== 'fallback'){
        reply = kbResult.answer;
      } else {
        // Otherwise try LLM, then fallback to KB if LLM is unavailable or returns nothing
          try {
            if(window.lumi && typeof window.lumi.think === 'function'){
              // attempt retrieval from file-backed memory to augment prompt
              try{
                if(window.lumi && typeof window.lumi.memoryQuery === 'function'){
                  const mres = await window.lumi.memoryQuery(q, 6);
                  if(mres && mres.ok && Array.isArray(mres.results) && mres.results.length){
                    // build brief context from recent memory entries
                    const ctx = mres.results.slice(0,6).map(r=>`[${r.role||'mem'}] ${ (r.text||'').toString().slice(0,480) }`).join('\n');
                    const augmented = `Context (from Lumi memory):\n${ctx}\n\nUser question:\n${q}`;
                    const res = await window.lumi.think(augmented);
                    if(res && res.output) reply = res.output;
                    else {
                      const synth = kbSynthesize(q, 5);
                      if(synth && synth.answer) reply = synth.answer + '\n\n(From Lumi KB — synthesized offline answer, confidence ' + Math.round((synth.confidence||0)*100) + '%)';
                      else if(kbResult && kbResult.answer) reply = kbResult.answer + '\n\n(Provided from Lumi KB as fallback)';
                      else reply = "I can't reach the model right now and couldn't find a direct KB answer. Try rephrasing or ask me to search the KB.";
                    }
                  } else {
                    const res = await window.lumi.think(q);
                    if(res && res.output) reply = res.output;
                    else {
                      const synth = kbSynthesize(q, 5);
                      if(synth && synth.answer) reply = synth.answer + '\n\n(From Lumi KB — synthesized offline answer, confidence ' + Math.round((synth.confidence||0)*100) + '%)';
                      else if(kbResult && kbResult.answer) reply = kbResult.answer + '\n\n(Provided from Lumi KB as fallback)';
                      else reply = "I can't reach the model right now and couldn't find a direct KB answer. Try rephrasing or ask me to search the KB.";
                    }
                  }
                } else {
                  const res = await window.lumi.think(q);
                  if(res && res.output) reply = res.output;
                  else if(kbResult && kbResult.answer) reply = kbResult.answer + '\n\n(Provided from Lumi KB as fallback)';
                  else reply = "I can't reach the model right now and couldn't find a direct KB answer. Try rephrasing or ask me to search the KB.";
                }
              }catch(memErr){
                console.warn('memoryQuery failed', memErr);
                const res = await window.lumi.think(q);
                if(res && res.output) reply = res.output;
                else {
                  const synth = kbSynthesize(q, 5);
                  if(synth && synth.answer) reply = synth.answer + '\n\n(From Lumi KB — synthesized offline answer, confidence ' + Math.round((synth.confidence||0)*100) + '%)';
                  else if(kbResult && kbResult.answer) reply = kbResult.answer + '\n\n(Provided from Lumi KB as fallback)';
                  else reply = "I can't reach the model right now and couldn't find a direct KB answer. Try rephrasing or ask me to search the KB.";
                }
              }
            } else {
              // LLM not available — prefer KB answer if present
              if(kbResult && kbResult.answer){ const synth = kbSynthesize(q,5); if(synth && synth.answer) reply = synth.answer + '\n\n(From Lumi KB — offline synthesis, confidence ' + Math.round((synth.confidence||0)*100) + '%)'; else reply = kbResult.answer + '\n\n(Provided from Lumi KB — offline mode)'; }
              else reply = "I can't reach the language model right now. I searched my KB but couldn't find a clear answer. Try rephrasing or ask me to search the KB.";
            }
          } catch(e){
            console.warn('lumi.think failed:', e);
            if(kbResult && kbResult.answer){ const synth = kbSynthesize(q,5); if(synth && synth.answer) reply = synth.answer + '\n\n(From Lumi KB — fallback synthesis, confidence ' + Math.round((synth.confidence||0)*100) + '%)'; else reply = kbResult.answer + '\n\n(Provided from Lumi KB — fallback after error)'; }
            else reply = "I can't reach the language model right now and an error occurred. Try again or ask me to search the KB.";
          }
      }
      
      showThinking(false);
      // personalize short replies by injecting a gentle prefix for personality
      const p = loadPersona();
      const tone = (p && p.tone) ? normalizeTone(p.tone) : '';
      const displayReply = renderReplyWithTone(tone, reply);
      say(displayReply);
      // record assistant reply with persona metadata so each user sees the persona name they set
      try{ const p = loadPersona(); recordConversation('assistant', reply, {persona: p.name}); }catch(e){ recordConversation('assistant', reply); }
      // auto-log assistant answer to main so correct answers are captured for later training
      try{
        if(window.lumi && typeof window.lumi.logAssistant === 'function'){
          try{ window.lumi.logAssistant(q, reply, 0.92).then(r=>{ try{ console.log('[Renderer] logAssistant result:', r); }catch(_){ } }).catch(()=>{}); }catch(_){ }
        }
      }catch(_){ }
      // store last assistant Q/A for the mark-helpful action
      try{ _lastAssistantQA.q = q; _lastAssistantQA.a = reply; }catch(_){ }
      questionInput.value='';
      try{ if(typeof autoResizeQuestion === 'function') autoResizeQuestion(); }catch(_){ }
    }

    /* Feedback UI + teach (uses dialog)
       NOTE: Inline bubble feedback (from `say()`) is used as the single feedback system.
       Avoid creating a second floating feedback box to prevent duplicate controls. */
    function showFeedback(question,res){
      // noop: bubble already contains feedback buttons (👍 👎 Teach).
      // We still record lightweight metrics or expose hooks here if needed.
      return;
    }

    function recordFeedback(q,ok,res){
      const kb = loadKB();
      if(res && res.entry){
        res.entry.count = (res.entry.count||0) + (ok?1:-1);
        res.entry.lastFeedback = {ok,at:Date.now()};
        saveKB(kb);
      }
    }

    async function promptCorrection(question){
      const userVal = await showDialog('I was wrong — what is the correct short answer for:\n"' + question + '"','');
      if(userVal && userVal.trim()){ addOrUpdateKB(question, userVal.trim()); }
      else say('Okay — you can teach me anytime.',2000,{feedback:false});
    }

    function addOrUpdateKB(question,answer){
      const kb = loadKB();
      const q = question.trim(), a = answer.trim();
      // compute embedding for the new QA pair
      let newEmb = null;
      try{ newEmb = computeEmbedding((q||'') + ' ' + (a||'')); }catch(e){ newEmb = null; }
      // try to find exact match first
      const existing = kb.qa.find(x=>x.q.toLowerCase()===q.toLowerCase());
      if(existing){
        existing.a = a; existing.updatedAt = Date.now(); existing.count = (existing.count||0)+1;
        try{ existing.embedding = newEmb || existing.embedding || computeEmbedding((existing.q||'') + ' ' + (existing.a||'')); }catch(_){ }
      } else {
        // try to find a semantically similar existing question (embedding similarity)
        let merged = false;
        if(newEmb){
          for(const e of (kb.qa||[])){
            if(e.embedding){ const sc = cosineSim(newEmb, e.embedding); if(sc > 0.86){ // high similarity -> update
                e.a = a; e.updatedAt = Date.now(); e.count = (e.count||0)+1; try{ e.embedding = newEmb; }catch(_){} merged = true; break; }
            }
          }
        }
        if(!merged){ kb.qa.unshift({q,a,createdAt:Date.now(),count:1,embedding:newEmb}); if(kb.qa.length>2000) kb.qa.pop(); }
      }
      saveKB(kb); say('Thanks — I learned that.',2000,{feedback:false});
    }

    /* Code analysis (minimal) */
    function analyzeCode(code){
      const trimmed = code.trim();
      const isJS = /\\b(function|const|let|var|=>|console\\.)/.test(trimmed);
      const isPython = /\\b(def|import|from|print)\\b/.test(trimmed);
      const issues=[]; let fixed=code;
      const stack=[]; const pairs={'(':')','[':']','{':'}'};
      for(let ch of code){ if('([{'.includes(ch)) stack.push(ch); else if(')]}'.includes(ch)){ const last=stack.pop(); if(!last || pairs[last]!==ch) issues.push('Mismatched bracket: '+ch); } }
      if(stack.length){ issues.push('Unclosed brackets detected: '+stack.join(' ')); fixed = fixed + '\n' + stack.map(()=>'}').join(''); }
      if(isJS){
        fixed = fixed.split('\n').map(line=>{ const t=line.trim(); if(!t) return line; if(t.endsWith(';')||t.endsWith('{')||t.endsWith('}')||t.startsWith('//')||t.includes('=>')) return line; if(/^\\s*(if|for|while|else|switch|case|function)\\b/.test(t)) return line; return line+';'; }).join('\n');
        fixed = fixed.replace(/\\bvar\\s+/g,'let ');
      }
      fixed = fixed.split('\n').map(l=>l.replace(/\\t/g,'  ')).join('\n');
      return {fixed, issues: issues.length?issues:['No obvious issues detected (I might still be wrong).'], confidence: isJS?0.6:(isPython?0.5:0.4), language: isJS?'javascript':(isPython?'python':'unknown')};
    }

    analyzeBtn.addEventListener('click', async ()=>{
      const code = codeInput.value||'';
      if(!code.trim()){ say('Paste some code first.',2000,{feedback:false}); return; }
      showThinking(true);
      await new Promise(r=>setTimeout(r,700));
      const res = analyzeCode(code);
      try{ res.language = res.language || (codeInput && codeInput.dataset && codeInput.dataset.lang) || detectLanguage(code) || 'unknown'; }catch(_){ res.language = res.language || 'unknown'; }
      showThinking(false);
      analysisArea.textContent = 'Language: '+res.language+'\\nConfidence: '+Math.round(res.confidence*100)+'%\\n\\nIssues:\\n- '+res.issues.join('\\n- ')+'\\n\\nSuggested Fixes (preview):\\n'+res.fixed;
      const mainPath = (codeInput.dataset && codeInput.dataset.path) || 'main.js';
      res.base = code;
      res.path = mainPath;
      analysisArea._last = res;
      recordConversation('user-code', code);
      recordConversation('lumi-analysis', analysisArea.textContent);
    });

    // --- Snapshot management: multi-file project workspaces persisted to localStorage ---
    const SNAP_KEY = 'lumi_snapshots_v1';
    const PROJECT_FILES_KEY = 'project_files_v1';

    function loadSnapshots(){ try{ const raw = JSON.parse(localStorage.getItem(SNAP_KEY)||'[]'); // migrate old single-file snapshots to project format
        if(Array.isArray(raw)){
          const migrated = raw.map(s => {
            if(s && (s.code !== undefined) && !s.files){
              return { id: s.id || ('snap_'+Date.now()), name: s.name || 'Snapshot', t: s.t || Date.now(), files: [{ path: s.path || 'main.js', code: s.code||'', lang: s.lang || detectLanguage(s.code||''), base: s.base || s.code||'' }] };
            }
            return s;
          });
          return migrated;
        }
        return [];
      }catch(e){ console.warn('loadSnapshots failed', e); return []; } }

    function saveSnapshots(snaps){ try{ localStorage.setItem(SNAP_KEY, JSON.stringify(snaps)); }catch(e){ console.warn('saveSnapshots failed', e); } }

    // Project files management (simple single-folder file list persisted locally)
    function loadProjectFiles(){ try{ return JSON.parse(localStorage.getItem(PROJECT_FILES_KEY) || '[]'); }catch(e){ return []; } }
    function saveProjectFiles(files){ try{ localStorage.setItem(PROJECT_FILES_KEY, JSON.stringify(files)); }catch(e){ console.warn('saveProjectFiles failed', e); } }

    // Basic three-way line-oriented merge. Returns merged string; conflicts are marked.
    function threeWayMerge(base, local, remote){
      base = (base||'').split('\n');
      local = (local||'').split('\n');
      remote = (remote||'').split('\n');
      const max = Math.max(base.length, local.length, remote.length);
      const out = [];
      for(let i=0;i<max;i++){
        const b = base[i]===undefined? '': base[i];
        const l = local[i]===undefined? '': local[i];
        const r = remote[i]===undefined? '': remote[i];
        if(l === r){ out.push(l); continue; }
        if(l === b && r !== b){ out.push(r); continue; }
        if(r === b && l !== b){ out.push(l); continue; }
        // conflict: include both
        out.push('<<<<<<< LOCAL');
        out.push(l);
        out.push('=======');
        out.push(r);
        out.push('>>>>>>> REMOTE');
      }
      return out.join('\n');
    }

    function createSnapshot(name, files){ try{
      const snaps = loadSnapshots();
      const projectFiles = Array.isArray(files) ? files : loadProjectFiles();
      // Ensure at least one file (current editor) exists
      if(!projectFiles.length){ projectFiles.push({ path: 'main.js', code: (codeInput.value||''), lang: (codeInput.dataset && codeInput.dataset.lang) || detectLanguage(codeInput.value||''), base: (codeInput.value||'') }); }
      const s = { id: 'snap_' + Date.now(), name: name || ('Snapshot ' + new Date().toISOString()), files: projectFiles.map(f=> ({ path: f.path||'file', code: f.code||'', lang: f.lang||detectLanguage(f.code||''), base: f.base || (f.code||'') })), t: Date.now() };
      snaps.unshift(s); if(snaps.length>100) snaps.pop(); saveSnapshots(snaps); renderSnapshotList(); return s;
    }catch(e){ console.warn('createSnapshot failed', e); return null; } }

    function deleteSnapshot(id){ try{ let snaps = loadSnapshots(); snaps = snaps.filter(s=>s.id!==id); saveSnapshots(snaps); renderSnapshotList(); }catch(e){ console.warn('deleteSnapshot failed', e);} }

    // apply snapshot: supports modes 'replace' (overwrite), 'merge' (three-way), 'append' (concatenate)
    function applySnapshot(id, opts){ try{ const snaps = loadSnapshots(); const s = snaps.find(x=>x.id===id); if(!s) return false; const mode = (opts && opts.mode) || 'merge'; const currentFiles = loadProjectFiles(); // map by path
      const fileMap = Object.create(null); currentFiles.forEach(f=> fileMap[f.path] = f);
      // helper to write back to current workspace (update project files + main editor if path matches)
      function writeFile(path, newCode, lang){ if(fileMap[path]){ fileMap[path].code = newCode; if(lang) fileMap[path].lang = lang; } else { fileMap[path] = { path, code: newCode, lang: lang||detectLanguage(newCode||'') }; }
        // if path matches main editor path, update textarea
        const mainPath = (codeInput.dataset && codeInput.dataset.path) || 'main.js';
        if(path === mainPath){ codeInput.value = newCode; codeInput.dataset.lang = lang || detectLanguage(newCode||''); }
      }

      const conflictCandidates = [];
      for(const sf of (s.files||[])){
        const cur = fileMap[sf.path] || { path: sf.path, code: '', lang: '' };
        if(mode === 'replace'){
          writeFile(sf.path, sf.code, sf.lang);
        } else if(mode === 'append'){
          writeFile(sf.path, (cur.code || '') + '\n\n' + (sf.code||''), sf.lang || cur.lang);
        } else { // merge
          const merged = threeWayMerge(sf.base||'', cur.code||'', sf.code||'');
          // if merged contains conflict markers, queue for interactive resolution
          if(typeof merged === 'string' && /<<<<<<< LOCAL/.test(merged)){
            conflictCandidates.push({ path: sf.path, merged, lang: sf.lang || cur.lang, base: sf.base || '' });
          } else {
            writeFile(sf.path, merged, sf.lang || cur.lang);
          }
        }
      }

      // If there are conflicts, present an interactive resolver sequentially
      if(conflictCandidates.length){
        let idx = 0;
        const resolveNext = ()=>{
          if(idx >= conflictCandidates.length){ // done
            const outFiles = Object.keys(fileMap).map(k=> fileMap[k]); saveProjectFiles(outFiles); renderProjectFilesUI(); analysisArea.textContent = 'Applied snapshot with conflicts resolved: ' + s.name; return true; }
          const c = conflictCandidates[idx]; showConflictResolver(c.path, c.merged, (resolvedCode)=>{ try{ writeFile(c.path, resolvedCode, c.lang); idx++; resolveNext(); }catch(e){ console.warn(e); idx++; resolveNext(); } });
        };
        resolveNext();
        return true;
      }

      // persist project files back when no interactive conflicts
      const outFiles = Object.keys(fileMap).map(k=> fileMap[k]); saveProjectFiles(outFiles); renderProjectFilesUI(); analysisArea.textContent = 'Applied snapshot: ' + s.name; return true; }catch(e){ console.warn('applySnapshot failed', e); return false;} }

    // Conflict resolver UI: shows merged text and helpers to replace individual conflict hunks with LOCAL or REMOTE
    function showConflictResolver(path, mergedText, onResolve){ try{
      const panel = document.getElementById('snapshotPanel'); if(!panel) return;
      // create resolver container
      let resolver = document.getElementById('conflictResolver');
      if(resolver) resolver.remove();
      resolver = document.createElement('div'); resolver.id = 'conflictResolver'; resolver.style.padding = '10px'; resolver.style.background = '#0b1220'; resolver.style.border = '1px solid rgba(255,255,255,0.04)'; resolver.style.marginTop = '8px';
      resolver.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><strong style="color:#fff">Resolve conflicts: ${escapeHtml(path)}</strong><div><button id="cr-cancel" class="tiny">Cancel</button><button id="cr-accept" class="tiny" style="margin-left:8px">Accept</button></div></div><div style="margin-top:8px;color:#cbd5e1;font-size:12px">Preview and resolve conflict hunks. Use the helper buttons to replace the currently highlighted conflict with LOCAL or REMOTE content, or manually edit the preview.</div><textarea id="cr-preview" style="width:100%;height:360px;margin-top:8px;font-family:monospace">${escapeHtml(mergedText)}</textarea><div style="margin-top:8px;display:flex;gap:8px"><button id="cr-next" class="tiny">Next Conflict</button><button id="cr-local" class="tiny">Replace with LOCAL</button><button id="cr-remote" class="tiny">Replace with REMOTE</button><button id="cr-both" class="tiny">Replace with BOTH</button></div>`;
      panel.appendChild(resolver);

      const preview = resolver.querySelector('#cr-preview'); const btnNext = resolver.querySelector('#cr-next'); const btnLocal = resolver.querySelector('#cr-local'); const btnRemote = resolver.querySelector('#cr-remote'); const btnBoth = resolver.querySelector('#cr-both'); const btnAccept = resolver.querySelector('#cr-accept'); const btnCancel = resolver.querySelector('#cr-cancel');

      function findNextConflict(fromIndex){ const re = /<<<<<<< LOCAL\n([\s\S]*?)\n=======\n([\s\S]*?)\n>>>>>>> REMOTE/; re.lastIndex = fromIndex || 0; const s = preview.value.slice(fromIndex||0); const m = s.match(re); if(!m) return null; const absIndex = (fromIndex||0) + s.indexOf(m[0]); return { index: absIndex, match: m, length: m[0].length }; }

      let lastPos = 0;
      btnNext.addEventListener('click', ()=>{ try{ const found = findNextConflict(lastPos); if(!found){ alert('No more conflicts.'); return; } preview.focus(); preview.setSelectionRange(found.index, found.index + found.length); lastPos = found.index + found.length; }catch(e){ console.warn(e); } });

      function replaceCurrent(mode){ try{ const text = preview.value; const re = /<<<<<<< LOCAL\n([\s\S]*?)\n=======\n([\s\S]*?)\n>>>>>>> REMOTE/; const m = re.exec(text); if(!m) return; const start = m.index; const end = m.index + m[0].length; let replacement = '';
          if(mode === 'local') replacement = m[1]; else if(mode === 'remote') replacement = m[2]; else if(mode === 'both') replacement = m[1] + '\n' + m[2];
          preview.value = text.slice(0,start) + replacement + text.slice(end);
      }catch(e){ console.warn(e); } }

      btnLocal.addEventListener('click', ()=> replaceCurrent('local'));
      btnRemote.addEventListener('click', ()=> replaceCurrent('remote'));
      btnBoth.addEventListener('click', ()=> replaceCurrent('both'));

      btnAccept.addEventListener('click', ()=>{ try{ const resolved = preview.value; resolver.remove(); onResolve(resolved); }catch(e){ console.warn(e); } });
      btnCancel.addEventListener('click', ()=>{ try{ resolver.remove(); // abort: do not apply file
          // continue by simply not writing this file (caller will proceed)
        }catch(e){ console.warn(e); } });
    }catch(e){ console.warn('showConflictResolver failed', e); } }

    function renderSnapshotList(){ try{ const listEl = document.getElementById('snapshotList'); if(!listEl) return; const snaps = loadSnapshots(); if(!snaps.length){ listEl.innerHTML = '<div style="color:var(--muted)">No snapshots yet.</div>'; return; }
      let html=''; for(const s of snaps){ html += `<div style="padding:8px;border-bottom:1px solid rgba(255,255,255,0.03)"><div style="font-size:12px;color:var(--muted)">${escapeHtml(new Date(s.t).toLocaleString())} — <strong>${escapeHtml(s.name)}</strong></div>`;
        // file list preview
        html += `<div style="margin-top:6px">`;
        for(const f of (s.files||[])){
          html += `<div style="margin-top:6px;white-space:pre-wrap;font-family:monospace;font-size:12px;color:#cfe8ff;max-height:64px;overflow:auto"><strong>${escapeHtml(f.path)}</strong> — ${escapeHtml((f.code||'').slice(0,300))}${(f.code && f.code.length>300 ? '…' : '')}</div>`;
        }
        html += `</div><div style="display:flex;gap:6px;justify-content:flex-end;margin-top:6px"><button class="tiny snap-apply" data-id="${s.id}">Merge</button><button class="tiny snap-apply-replace" data-id="${s.id}">Replace</button><button class="tiny snap-delete" data-id="${s.id}">Delete</button></div></div>`;
      }
      listEl.innerHTML = html;
      const applies = listEl.querySelectorAll('.snap-apply'); applies.forEach(b=> b.addEventListener('click', ()=>{ try{ const id=b.dataset.id; if(!id) return; showDialog('Apply snapshot (three-way merge)? Type OK to confirm.','OK').then(ans=>{ if(ans){ applySnapshot(id, {mode:'merge'}); renderSnapshotList(); } }); }catch(e){ console.warn(e); } }));
      const replaces = listEl.querySelectorAll('.snap-apply-replace'); replaces.forEach(b=> b.addEventListener('click', ()=>{ try{ const id=b.dataset.id; if(id){ applySnapshot(id, {mode:'replace'}); renderSnapshotList(); } }catch(e){ console.warn(e); } }));
      const dels = listEl.querySelectorAll('.snap-delete'); dels.forEach(b=> b.addEventListener('click', ()=>{ try{ const id=b.dataset.id; if(!id) return; if(!confirm('Delete snapshot?')) return; deleteSnapshot(id); }catch(e){ console.warn(e); } }));
    }catch(e){ console.warn('renderSnapshotList failed', e);} }

    // Project files UI (simple file-tree manager inside snapshotPanel)
    function renderProjectFilesUI(){ try{ const panel = document.getElementById('snapshotPanel'); if(!panel) return; let mgr = document.getElementById('projectFilesManager'); if(!mgr){ mgr = document.createElement('div'); mgr.id = 'projectFilesManager'; mgr.style.padding = '8px'; mgr.style.borderTop = '1px solid rgba(255,255,255,0.03)'; panel.appendChild(mgr); }
      const files = loadProjectFiles(); let html = '<div style="display:flex;align-items:center;justify-content:space-between"><strong>Project Files</strong><div><button id="addProjectFile" class="tiny">Add File</button><button id="saveProjectFiles" class="tiny">Save Files</button></div></div>';
      if(!files.length) html += '<div style="color:var(--muted);margin-top:8px">No project files. Add files to create multi-file snapshots.</div>';
      for(const f of files){ html += `<div style="padding:6px;border-bottom:1px solid rgba(255,255,255,0.03);display:flex;gap:8px;align-items:flex-start"><div style="flex:1"><div style="font-size:12px;color:var(--muted)">${escapeHtml(f.path)}</div><textarea class="project-file-code" data-path="${escapeHtml(f.path)}" style="width:100%;height:120px;font-family:monospace;margin-top:6px">${escapeHtml(f.code||'')}</textarea></div><div style="display:flex;flex-direction:column;gap:6px"><button class="tiny pf-delete" data-path="${escapeHtml(f.path)}">Delete</button></div></div>`; }
      mgr.innerHTML = html;
      // attach handlers
      const addBtn = document.getElementById('addProjectFile'); if(addBtn) addBtn.onclick = async ()=>{ try{ const name = await showDialog('New file path?','newfile.txt'); if(!name) return; const files = loadProjectFiles(); files.push({ path: name, code: '' }); saveProjectFiles(files); renderProjectFilesUI(); }catch(e){ console.warn(e);} };
      const saveBtn = document.getElementById('saveProjectFiles'); if(saveBtn) saveBtn.onclick = ()=>{ try{ const areas = mgr.querySelectorAll('.project-file-code'); const files = []; areas.forEach(a=> files.push({ path: a.dataset.path, code: (a.value||''), lang: detectLanguage(a.value||'') })); saveProjectFiles(files); say('Project files saved.',1500,{feedback:false}); renderProjectFilesUI(); }catch(e){ console.warn(e);} };
      const dels = mgr.querySelectorAll('.pf-delete'); dels.forEach(b=> b.addEventListener('click', ()=>{ try{ const p = b.dataset.path; if(!p) return; let files = loadProjectFiles(); files = files.filter(x=>x.path !== p); saveProjectFiles(files); renderProjectFilesUI(); }catch(e){ console.warn(e);} }));
    }catch(e){ console.warn('renderProjectFilesUI failed', e); } }

    // Snapshot buttons
    const saveSnapshotBtn = document.getElementById('saveSnapshot');
    const openSnapshotsBtn = document.getElementById('openSnapshots');
    const closeSnapshotsBtn = document.getElementById('closeSnapshots');
    const saveSnapshotQuick = document.getElementById('saveSnapshotQuick');
    const downloadSnapshotsBtn = document.getElementById('downloadSnapshots');
    if(saveSnapshotBtn) saveSnapshotBtn.addEventListener('click', async ()=>{ try{ const name = await showDialog('Snapshot name?','My Snapshot'); if(name){ createSnapshot(name); say('Snapshot saved.',2000,{feedback:false}); } else say('Snapshot canceled.',1200,{feedback:false}); }catch(e){ console.warn(e);} });
    if(saveSnapshotQuick) saveSnapshotQuick.addEventListener('click', ()=>{ try{ createSnapshot(); say('Snapshot saved (quick).',1500,{feedback:false}); }catch(e){ console.warn(e);} });
    if(openSnapshotsBtn) openSnapshotsBtn.addEventListener('click', ()=>{ try{ document.getElementById('snapshotPanel').style.display='block'; renderSnapshotList(); renderProjectFilesUI(); }catch(e){} });
    if(closeSnapshotsBtn) closeSnapshotsBtn.addEventListener('click', ()=>{ try{ document.getElementById('snapshotPanel').style.display='none'; }catch(e){} });
    if(downloadSnapshotsBtn) downloadSnapshotsBtn.addEventListener('click', ()=>{ try{ const snaps = loadSnapshots(); const blob = new Blob([JSON.stringify(snaps,null,2)],{type:'application/json'}); const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='lumi_snapshots.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); say('Snapshots exported.',2000,{feedback:false}); }catch(e){ console.warn(e);} });

    // Assistant hooks for programmatic snapshot access + project file APIs
    try{ if(!window.lumi) window.lumi = {};
      window.lumi.saveSnapshot = async function(name){ return createSnapshot(name); };
      window.lumi.listSnapshots = function(){ return loadSnapshots(); };
      window.lumi.applySnapshot = function(id, opts){ return applySnapshot(id, opts); };
      window.lumi.saveProjectFiles = function(files){ try{ saveProjectFiles(files || loadProjectFiles()); return {ok:true}; }catch(e){ return {ok:false,error:e.toString()}; } };
      window.lumi.listProjectFiles = function(){ return loadProjectFiles(); };
    }catch(e){ console.warn('exposing snapshot hooks failed', e); }

    // Editor runtime contract for enhanced React components (mount/update callbacks)
    try{
      if(!window.editorRuntime) window.editorRuntime = {};
      // mount(mountElement, options) -> { ready:true }
      window.editorRuntime.mount = window.editorRuntime.mount || (async function(mountEl, opts){
        // default host: wire textarea to behave like a file-based editor
        try{
          // ensure codeInput change dispatches file updates
          codeInput.addEventListener('input', ()=>{
            const mainPath = (codeInput.dataset && codeInput.dataset.path) || 'main.js';
            const files = loadProjectFiles(); const f = files.find(x=>x.path===mainPath);
            if(f){ f.code = codeInput.value; saveProjectFiles(files); }
            if(window.editorRuntime._onFileChange) window.editorRuntime._onFileChange(mainPath, codeInput.value);
          });
        }catch(e){ }
        return { ready: true };
      });
      window.editorRuntime.updateFiles = window.editorRuntime.updateFiles || function(files){ try{ if(!Array.isArray(files)) return; // write into project files and update main editor if necessary
          saveProjectFiles(files.map(f=>({ path: f.path, code: f.code, lang: f.lang||detectLanguage(f.code||'') })));
          const mainPath = (codeInput.dataset && codeInput.dataset.path) || 'main.js';
          const main = files.find(f=>f.path === mainPath);
          if(main) { codeInput.value = main.code; codeInput.dataset.lang = main.lang || detectLanguage(main.code||''); }
          renderProjectFilesUI();
        }catch(e){ console.warn('editorRuntime.updateFiles failed', e); } };
      window.editorRuntime.onFileChange = window.editorRuntime.onFileChange || function(cb){ window.editorRuntime._onFileChange = cb; };
      window.editorRuntime.requestAnalyze = window.editorRuntime.requestAnalyze || function(path){ try{ const files = loadProjectFiles(); const f = files.find(x=>x.path===path); if(!f) return null; const res = analyzeCode(f.code||''); res.language = res.language || f.lang || detectLanguage(f.code||''); return res; }catch(e){ return null; } };
    }catch(e){ console.warn('editorRuntime init failed', e); }

    function updateMainProjectFile(newCode, newLang){
      try{
        const mainPath = (codeInput.dataset && codeInput.dataset.path) || 'main.js';
        const files = loadProjectFiles();
        const f = files.find(x=>x.path === mainPath);
        if(f){ f.code = newCode; f.lang = newLang || detectLanguage(newCode||''); f.base = newCode; }
        else files.push({ path: mainPath, code: newCode, lang: newLang || detectLanguage(newCode||''), base: newCode });
        saveProjectFiles(files);
      }catch(_){ }
    }

    formatBtn.addEventListener('click', ()=>{
      const code=codeInput.value||''; if(!code.trim()) return;
      const res=analyzeCode(code);
      codeInput.value=res.fixed;
      updateMainProjectFile(res.fixed, res.language || (codeInput.dataset && codeInput.dataset.lang));
      analysisArea.textContent='Applied basic formatting and fixes. Preview updated.';
    });

    applyFixBtn.addEventListener('click', ()=>{
      if(!analysisArea._last){ say('No suggested fix available yet.',2000,{feedback:false}); return; }
      const last = analysisArea._last;
      const current = codeInput.value || '';
      const base = last.base || current;
      const fixed = last.fixed || current;
      let merged = fixed;
      if(base && current && fixed && current !== base){
        merged = threeWayMerge(base, current, fixed);
      }
      if(/<<<<<<< LOCAL/.test(merged)){
        showConflictResolver(last.path || ((codeInput.dataset && codeInput.dataset.path) || 'main.js'), merged, (resolved)=>{
          codeInput.value = resolved;
          updateMainProjectFile(resolved, last.language || (codeInput.dataset && codeInput.dataset.lang));
          analysisArea._last = Object.assign({}, last, { base: resolved });
          say('Applied suggested fixes with conflicts resolved.',2000,{feedback:false});
        });
        return;
      }
      codeInput.value = merged;
      updateMainProjectFile(merged, last.language || (codeInput.dataset && codeInput.dataset.lang));
      analysisArea._last = Object.assign({}, last, { base: merged });
      say('Applied suggested fixes to the editor.',2000,{feedback:false});
    });

    openCode.addEventListener('click', ()=> codePanel.style.display='block');
    closeCode.addEventListener('click', ()=> codePanel.style.display='none');

    function showThinking(on){ try{ const n = (loadPersona && loadPersona().name) || 'Lumi'; if(on) bubble.textContent = n + ' is thinking...'; }catch(e){ if(on) bubble.textContent='Lumi is thinking...'; } bubble.style.display = on? 'block':'none'; }

    /* Persona editor events */
    openSettings.addEventListener('click', ()=>{
      try{
        const last = localStorage.getItem('lumi_last_settings_tab') || 'general';
        showSettingsTab(last || 'general');
        if (last !== 'general') showSettingsTab('general');
      }catch(e){ try{ showSettingsTab('general'); }catch(_){ } }
      settingsPanel.style.display='block';
    });
    closeSettings.addEventListener('click', ()=> settingsPanel.style.display='none');
    if (openPersonality) openPersonality.addEventListener('click', ()=>{ try{ showSettingsTab('personality'); if(settingsPanel) settingsPanel.style.display='block'; }catch(e){ console.warn(e); } });
    if (closePersonality) closePersonality.addEventListener('click', ()=>{ try{ if(settingsPanel) settingsPanel.style.display='none'; }catch(e){} });
    savePersona.addEventListener('click', ()=>{
      try{
        // Users may edit name/interests, but tone is controlled by Lumi herself.
        const existing = loadPersona() || {};
        const p = { name: (personaName.value||existing.name||'Lumi'), tone: existing.tone || 'playful', interests: (personaInterests.value||existing.interests||'coding,cats') };
        savePersonaToStorage(p, {origin:'manual'});
        say('Persona saved (tone is managed by Lumi).',2000,{feedback:false});
      }catch(e){ console.warn('savePersona handler failed', e); }
    });
    resetPersona.addEventListener('click', ()=>{ localStorage.removeItem(PERSONA_KEY); const p=defaultPersona(); savePersonaToStorage(p, {origin:'manual', note:'reset'}); say('Persona reset.',2000,{feedback:false}); });

    const openPersonaHistory = document.getElementById('openPersonaHistory');
    const personaHistoryPanel = document.getElementById('personaHistoryPanel');
    const personaHistoryList = document.getElementById('personaHistoryList');
    const personaHistoryClose = document.getElementById('personaHistoryClose');
    const personaHistoryClear = document.getElementById('personaHistoryClear');

    function loadPersonaHistory(){ try{ return JSON.parse(localStorage.getItem(PERSONA_HISTORY_KEY) || '[]'); }catch(e){ return []; } }
    function renderPersonaHistory(){ try{
      if(!personaHistoryList) return;
      const hist = loadPersonaHistory(); if(!hist.length){ personaHistoryList.innerHTML = '<div style="color:var(--muted)">No persona history yet.</div>'; return; }
      let html=''; for(let i = hist.length-1; i>=0; i--){ const h = hist[i]; const t = new Date(h.t||Date.now()).toLocaleString(); const origin = h.origin || 'manual'; const accepted = h.accepted ? ' (accepted)' : ''; const p = h.persona || {}; html += `<div style="padding:8px;border-bottom:1px solid rgba(255,255,255,0.03)"><div style="font-size:12px;color:var(--muted)">${escapeHtml(origin)} — ${escapeHtml(t)}${accepted}</div><div style="margin-top:6px">Name: <strong>${escapeHtml(p.name||'')}</strong></div><div style="margin-top:4px">Tone: ${escapeHtml(p.tone||'')}</div><div style="margin-top:4px">Interests: ${escapeHtml(p.interests||'')}</div><div style="margin-top:6px;display:flex;gap:6px;justify-content:flex-end"><button class="tiny persona-accept" data-idx="${i}">Accept</button><button class="tiny persona-revert" data-idx="${i}">Revert to</button><button class="tiny persona-reject" data-idx="${i}">Reject</button></div></div>`; }
      personaHistoryList.innerHTML = html; 
      // attach handlers
      const accepts = personaHistoryList.querySelectorAll('.persona-accept'); accepts.forEach(b=> b.addEventListener('click', async (ev)=>{ try{ const idx = parseInt(b.dataset.idx,10); const hist = loadPersonaHistory(); const entry = hist[idx]; if(entry){ entry.accepted = true; localStorage.setItem(PERSONA_HISTORY_KEY, JSON.stringify(hist)); savePersonaToStorage(entry.persona, {origin:'accepted', note:'accepted from history'}); renderPersonaHistory(); say('Persona accepted.',2000,{feedback:false}); } }catch(e){ console.warn(e); } }));
      const reverts = personaHistoryList.querySelectorAll('.persona-revert'); reverts.forEach(b=> b.addEventListener('click', async (ev)=>{ try{ const idx = parseInt(b.dataset.idx,10); const hist = loadPersonaHistory(); const entry = hist[idx]; if(entry){ savePersonaToStorage(entry.persona, {origin:'revert', note:'reverted from history'}); renderPersonaHistory(); say('Persona reverted.',2000,{feedback:false}); } }catch(e){ console.warn(e); } }));
      const rejects = personaHistoryList.querySelectorAll('.persona-reject'); rejects.forEach(b=> b.addEventListener('click', async (ev)=>{ try{ const idx = parseInt(b.dataset.idx,10); const hist = loadPersonaHistory(); const entry = hist[idx]; if(entry){ entry.rejected = true; entry.accepted = false; localStorage.setItem(PERSONA_HISTORY_KEY, JSON.stringify(hist)); renderPersonaHistory(); say('Persona rejected.',2000,{feedback:false}); } }catch(e){ console.warn(e); } }));
    }catch(e){ console.warn('renderPersonaHistory failed', e); } }

    if(openPersonaHistory) openPersonaHistory.addEventListener('click', ()=>{ try{ renderPersonaHistory(); showSettingsTab('personality'); if(settingsPanel) settingsPanel.style.display='block'; if(personaHistoryPanel) personaHistoryPanel.style.display='block'; }catch(e){ console.warn(e); } });
    if(personaHistoryClose) personaHistoryClose.addEventListener('click', ()=>{ try{ if(personaHistoryPanel) personaHistoryPanel.style.display='none'; }catch(e){} });
    if(personaHistoryClear) personaHistoryClear.addEventListener('click', ()=>{ try{ if(!confirm('Clear persona history?')) return; localStorage.removeItem(PERSONA_HISTORY_KEY); renderPersonaHistory(); say('Persona history cleared.',2000,{feedback:false}); }catch(e){ console.warn(e); } });
    
    // Model filename selector
    const modelFilenameInput = document.getElementById('modelFilename');
    const loadModelBtn = document.getElementById('loadModelBtn');
    
    // Load saved model preference
    try {
      const savedModel = localStorage.getItem('lumi_model_filename');
      if (savedModel && modelFilenameInput) {
        modelFilenameInput.value = savedModel;
      }
    } catch (e) {}
    
    // Load model button handler
    if (loadModelBtn && modelFilenameInput) {
      loadModelBtn.addEventListener('click', () => {
        const filename = (modelFilenameInput.value || '').trim();
        if (!filename) {
          say('Please enter a model filename.', 2000, { feedback: false });
          return;
        }
        try {
          localStorage.setItem('lumi_model_filename', filename);
          // Try to load immediately if the 3D loader is available
          try {
            if (window.codelumiAdmin && typeof window.codelumiAdmin.loadSample === 'function') {
              window.codelumiAdmin.loadSample(filename);
              say('Model set to: ' + filename + ' — loaded.', 3000, { feedback: false });
            } else {
              say('Model set to: ' + filename + '. Restart the app to load it.', 3000, { feedback: false });
            }
          } catch (_e) {
            say('Model set to: ' + filename + '. Restart the app to load it.', 3000, { feedback: false });
          }
        } catch (e) {
          say('Error saving model preference.', 2000, { feedback: false });
        }
      });
    }
    
    // Animations toggle button
    const toggleAnimationsBtn = document.getElementById('toggleAnimations');
    const animationsSection = document.getElementById('animationsSection');
    if(toggleAnimationsBtn && animationsSection) {
      toggleAnimationsBtn.addEventListener('click', ()=>{ 
        const isHidden = animationsSection.style.display === 'none';
        animationsSection.style.display = isHidden ? 'block' : 'none';
        toggleAnimationsBtn.textContent = isHidden ? 'Hide Animations' : 'Animations';
      });
    }

    // load & bind global settings
    try{
      const s = loadSettings();
      const fbEl = codelumiFeedbackToggle || document.getElementById('lumiFeedbackToggle') || document.getElementById('codelumiFeedbackToggle'); if(fbEl){ fbEl.checked = !!s.feedbackEnabled; fbEl.addEventListener('change', ()=>{ s.feedbackEnabled = !!fbEl.checked; saveSettings(s); say(s.feedbackEnabled? 'Feedback enabled':'Feedback disabled',1500,{feedback:false}); }); }
      const atEl = document.getElementById('codelumiAutoTrainToggle'); if(atEl){ atEl.checked = !!s.autoTrain; atEl.addEventListener('change', ()=>{ s.autoTrain = !!atEl.checked; saveSettings(s); say(s.autoTrain? 'Auto-train enabled':'Auto-train disabled',1500,{feedback:false}); }); }
      const spinEl = document.getElementById('codelumiSpinOnOpen'); if(spinEl){ spinEl.checked = !!s.spinOnOpen; spinEl.addEventListener('change', ()=>{ s.spinOnOpen = !!spinEl.checked; saveSettings(s); try{ if(window.codelumiAnimations && typeof window.codelumiAnimations.setRotateEnabled === 'function'){ window.codelumiAnimations.setRotateEnabled(!!s.spinOnOpen); if(!s.spinOnOpen && typeof window.codelumiAnimations.getMode === 'function'){ const m = window.codelumiAnimations.getMode(); if(m === 'spin'){ window.codelumiAnimations.setMode('idle'); } } } }catch(_){ } say(s.spinOnOpen? 'Will spin on open':'Will not spin on open',1500,{feedback:false}); }); }
      const apEl = document.getElementById('lumiAutoPersonaToggle'); if(apEl){ apEl.checked = !!s.autoPersona; apEl.addEventListener('change', ()=>{ s.autoPersona = !!apEl.checked; saveSettings(s); say(s.autoPersona? 'Auto‑personalize enabled':'Auto‑personalize disabled',1500,{feedback:false}); }); }
    }catch(e){ console.warn('settings init failed', e); }

    /* shutdown helpers (same as before) */
    async function sha256Hex(msg){ const buf=new TextEncoder().encode(msg); const hash = await crypto.subtle.digest('SHA-256', buf); return Array.from(new Uint8Array(hash)).map(b=>b.toString(16).padStart(2,'0')).join(''); }
    downloadKBBtn?.addEventListener('click', ()=>{ const kb=loadKB(); const blob=new Blob([JSON.stringify(kb,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='lumi_knowledge.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); });

    document.getElementById('modalCancel').addEventListener('click', ()=>{ try{ modal.close(); }catch(e){ modal.style.display='none'; } });
    document.getElementById('modalOk').addEventListener('click', ()=>{ try{ modal.close(); }catch(e){ modal.style.display='none'; } });

    // init
    // migrate legacy localStorage keys if present
    try{ migrateOldLocalStorage(); }catch(e){ console.warn('migration failed', e); }
    // purge legacy seed/demo KB entries that can poison self-learn
    try{ const kb0 = loadKB(); const kb1 = sanitizeKBObject(kb0); if(((kb1.qa||[]).length) !== ((kb0.qa||[]).length)){ saveKBLocalOnly(kb1); } }catch(_){ }
    // initializeSeedKB(); // COMMENTED OUT to avoid frontend creating embeddings on startup
    applyPersona(loadPersona());
    updateScore();
    try{ fetchAndRenderMetrics(); setInterval(fetchAndRenderMetrics, 10000); }catch(_){ }
    // ensure KB entries have embeddings (migrate)
    /*
    try{
      const kb = loadKB(); let changed = false;
      kb.qa = kb.qa || [];
      for(const e of kb.qa){ if(!e.embedding){ try{ e.embedding = computeEmbedding((e.q||'') + ' ' + (e.a||'')); changed = true; }catch(_){} } }
      if(changed) saveKB(kb);
    }catch(e){ console.warn('kb migrate failed', e); }
    */
    window.addEventListener('load', ()=>{ try{ const n = (loadPersona && loadPersona().name) || 'Lumi'; say(n + ' is awake and ready — ask me about code.',4200,{feedback:false}); }catch(e){ say('Lumi is awake and ready — ask me about code.',4200,{feedback:false}); } });

    // Attempt to mount a React-based enhanced editor (if dev bundle exists). Falls back to textarea.
    try{
      (async ()=>{
        if(window.React && window.ReactDOM){
          try{
            const Comp = window.__CodeEditorEnhanced || null;
            const mountEl = document.getElementById('reactEditorMount');
            if(Comp && mountEl){
              mountEl.style.display = 'block';
              // create a wrapper that proxies textarea <-> react component
              const onChange = (v)=>{ try{ if(codeInput) codeInput.value = v; }catch(_){ } };
              const props = { value: (codeInput && codeInput.value) || '', language: (codeInput && codeInput.dataset && codeInput.dataset.lang) || detectLanguage(codeInput && codeInput.value||''), onChange };
              try{
                if (!mountEl._reactRoot) { mountEl._reactRoot = window.ReactDOM.createRoot ? window.ReactDOM.createRoot(mountEl) : null; }
                if (mountEl._reactRoot) { mountEl._reactRoot.render(window.React.createElement(Comp, props)); }
                else { window.ReactDOM.render(window.React.createElement(Comp, props), mountEl); }
                window._reactEditorMounted = true;
              } catch(e){ console.warn('React mount failed', e); }

              // provide a host->react event dispatch function; React component may listen for 'host-update'
              window._reactEditorUpdate = function(v){ try{ mountEl.dispatchEvent(new CustomEvent('host-update',{detail:v})); }catch(e){} };

              // keep React in sync when textarea changes (calls host update dispatcher)
              codeInput && codeInput.addEventListener('input', (ev)=>{ try{ const v = codeInput.value; if(window._reactEditorMounted){ try{ window._reactEditorUpdate(v); }catch(_){ } } }catch(_){ } });
            }
          }catch(e){ /* ignore missing dev component */ }
        }
      })();
    }catch(e){ }

    if(!window.lumi){ window.lumi = { saveKnowledge:(d)=>{ const kb=loadKB(); kb.qa=(d.qa||kb.qa); saveKB(kb); }, loadKnowledge:()=>loadKB(), shutdown:()=>{ const evt=new CustomEvent('lumi-shutdown'); window.dispatchEvent(evt); } }; }
    window.addEventListener('lumi-shutdown', ()=>{ try{ archiveCurrentSession('session_shutdown'); }catch(_){ } say('Shutdown requested',2000,{feedback:false}); setTimeout(()=>window.close(),300); });

    // autosave on unload
    window.addEventListener('beforeunload', ()=>{ try{ archiveCurrentSession('session_close'); }catch(_){ } try{ localStorage.setItem(KB_KEY, JSON.stringify(loadKB())); }catch(e){} });

    // Learning event toast: show brief notification when main process reports KB merges
    (function(){
      const toastId = 'lumiLearningToast';
      function showLearningToast(msg){
        try{
          let t = document.getElementById(toastId);
          if(!t){ t = document.createElement('div'); t.id = toastId; t.style.position='fixed'; t.style.right='24px'; t.style.top='20px'; t.style.zIndex='1000500'; t.style.background='linear-gradient(180deg,#0f1724,#0b1220)'; t.style.color='#e6eef8'; t.style.padding='10px 14px'; t.style.borderRadius='10px'; t.style.boxShadow='0 12px 40px rgba(0,0,0,0.6)'; t.style.maxWidth='360px'; t.style.fontSize='13px'; t.style.pointerEvents='auto'; document.body.appendChild(t); }
          t.textContent = '';
          const strong = document.createElement('div'); strong.style.fontWeight='700'; strong.style.marginBottom='6px'; strong.textContent = '✨ Lumi learned something';
          const body = document.createElement('div'); body.style.color='var(--muted)'; body.style.fontSize='12px'; body.style.whiteSpace='pre-wrap'; body.textContent = msg || '';
          t.appendChild(strong); t.appendChild(body);
          t.style.opacity = '1';
          clearTimeout(t._hide);
          t._hide = setTimeout(()=>{ try{ t.style.transition='opacity 360ms ease'; t.style.opacity='0'; setTimeout(()=>{ try{ t.remove(); }catch(_){ } }, 380); }catch(_){ } }, 3000);
        }catch(e){ console.warn('showLearningToast failed', e); }
      }

      try{
        if(window.lumi && typeof window.lumi.onLearningEvent === 'function'){
          window.lumi.onLearningEvent((ev)=>{
            try{
              // ev expected: { ok: true, merged: [...], confidence: 0.9, summary: '...' }
              if(!ev) return;
              const safeEv = Object.assign({}, ev);
              if (typeof safeEv.file === 'string') safeEv.file = safeDisplayPath(safeEv.file);
              if (typeof safeEv.path === 'string') safeEv.path = safeDisplayPath(safeEv.path);
              if (safeEv.entry && typeof safeEv.entry.path === 'string') safeEv.entry = Object.assign({}, safeEv.entry, { path: safeDisplayPath(safeEv.entry.path) });
              if (Array.isArray(safeEv.items)) {
                safeEv.items = safeEv.items.map(it => {
                  if (!it || typeof it !== 'object') return it;
                  if (typeof it.file === 'string') return Object.assign({}, it, { file: safeDisplayPath(it.file) });
                  if (typeof it.path === 'string') return Object.assign({}, it, { path: safeDisplayPath(it.path) });
                  return it;
                });
              }
              const conf = (ev.confidence || ev.conf || ev.c) ? Math.round((ev.confidence||ev.conf||ev.c)*100) + '%' : '';
              const summary = ev.summary || (Array.isArray(ev.merged) ? ev.merged.map(x=> (x.q||x.a||'')).slice(0,3).join(' • ') : '') || '';
              const msg = (summary ? summary + '\n' : '') + (conf ? 'Confidence: ' + conf : '');
              console.log('[Renderer] learning event received:', safeEv);
              showLearningToast(msg);
            }catch(e){ console.warn('learning event handler failed', e); }
          });
        }
      }catch(e){ }
    })();

  });
  </script>
  <script type="module">
  (async ()=>{
    // Create error overlay and collection
    const errors = [];
    function reportCrash(type, message, stack){
      try{
        if(window.lumi && typeof window.lumi.reportCrash === 'function'){
          window.lumi.reportCrash({ type, message: String(message||''), stack: String(stack||'') });
        }
      }catch(_){ }
    }
    function updateErrorBadge(){ const btn = document.getElementById('errBtn'); if(!btn) return; btn.textContent = `Errors (${errors.length})`; }
    function showErrorOverlay(){ let o = document.getElementById('errOverlay'); if(!o){ o = document.createElement('div'); o.id='errOverlay'; o.style.position='fixed'; o.style.right='12px'; o.style.bottom='60px'; o.style.width='420px'; o.style.maxHeight='60vh'; o.style.overflow='auto'; o.style.background='rgba(0,0,0,0.9)'; o.style.color='#fff'; o.style.padding='10px'; o.style.zIndex='1000000'; o.style.borderRadius='8px'; o.style.fontSize='12px'; document.body.appendChild(o); }
      o.innerHTML = '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px"><strong>Console Errors</strong><button id="errClose" style="background:#222;color:#fff;border:none;padding:4px 8px;border-radius:6px">Close</button></div>' + errors.map(e=>`<div style="margin-bottom:8px;border-top:1px solid rgba(255,255,255,0.06);padding-top:6px">${e}</div>`).join('');
      document.getElementById('errClose')?.addEventListener('click', ()=>{ document.getElementById('errOverlay')?.remove(); });
    }
    window.addEventListener('error', (ev)=>{ try{ const msg = `${ev.message} — ${ev.filename || ev.filename===undefined?ev.filename:''} :${ev.lineno||''}`; errors.unshift(msg); if(errors.length>200) errors.length=200; updateErrorBadge(); reportCrash('window.error', msg, ev.error && ev.error.stack); }catch(e){} });
    window.addEventListener('unhandledrejection', (ev)=>{ try{ const msg = (ev.reason && ev.reason.stack) ? ev.reason.stack : String(ev.reason); errors.unshift('UnhandledRejection: '+msg); if(errors.length>200) errors.length=200; updateErrorBadge(); reportCrash('unhandledrejection', msg, ev.reason && ev.reason.stack); }catch(e){} });
    // add errors button
    const errBtn = document.createElement('button'); errBtn.id='errBtn'; errBtn.style.position='fixed'; errBtn.style.left='12px'; errBtn.style.bottom='12px'; errBtn.style.zIndex='1000000'; errBtn.style.background='#ff6b81'; errBtn.style.color='#fff'; errBtn.style.border='none'; errBtn.style.padding='6px 10px'; errBtn.style.borderRadius='8px'; errBtn.style.cursor='pointer'; errBtn.textContent='Errors (0)'; errBtn.addEventListener('click', ()=> showErrorOverlay()); document.body.appendChild(errBtn);

    // One-click export logs for support
    const exportBtn = document.createElement('button');
    exportBtn.id = 'exportLogsBtn';
    exportBtn.textContent = 'Export Logs';
    exportBtn.style.position = 'fixed';
    exportBtn.style.left = '110px';
    exportBtn.style.bottom = '12px';
    exportBtn.style.zIndex = '1000000';
    exportBtn.style.background = '#2b3543';
    exportBtn.style.color = '#e6eef8';
    exportBtn.style.border = '1px solid #3a4658';
    exportBtn.style.padding = '6px 10px';
    exportBtn.style.borderRadius = '8px';
    exportBtn.style.cursor = 'pointer';
    exportBtn.addEventListener('click', async ()=>{
      try{
        exportBtn.disabled = true;
        const res = await (window.lumi && window.lumi.exportLogs ? window.lumi.exportLogs() : Promise.resolve({ ok:false, error:'exportLogs unavailable' }));
        if(res && res.ok){ try{ say('Logs exported to release_logs/', 2400, { feedback:false }); }catch(_){ alert('Logs exported to release_logs/'); } }
        else { try{ say('Export failed: ' + (res && res.error ? res.error : 'unknown'), 2400, { feedback:false }); }catch(_){ alert('Export failed'); } }
      }catch(e){ console.warn('Export logs failed', e); }
      finally { exportBtn.disabled = false; }
    });
    document.body.appendChild(exportBtn);

    try{
      const THREE = await import('three');
      const m = await import('three/examples/jsm/loaders/GLTFLoader.js');
      const GLTFLoader = m.GLTFLoader || m.default;
      const c = await import('three/examples/jsm/controls/OrbitControls.js');
      const OrbitControls = c.OrbitControls || c.default;

      // hide the SVG face in the UI
      const avatar = document.getElementById('avatarRoot');
      if(avatar){ const face = avatar.querySelector('.svg-face'); if(face) face.remove(); avatar.style.background='transparent'; avatar.style.boxShadow='none'; avatar.style.padding='0'; }

      // standalone 3D container - CENTER the model
      let modelContainer = document.getElementById('codelumi3d');
      if(!modelContainer){ modelContainer = document.createElement('div'); modelContainer.id = 'codelumi3d'; document.body.appendChild(modelContainer); }
      // Position 3D model in CENTER-LEFT and UP to avoid chat box overlap
      Object.assign(modelContainer.style, {position:'fixed', left:'38%', top:'38%', transform:'translate(-50%, -50%)', width:'420px', height:'420px', zIndex:9990, pointerEvents:'auto', background:'transparent'});

      const canvas = document.createElement('canvas'); canvas.id = 'codelumiCanvas'; canvas.width = 768; canvas.height = 768; canvas.style.width='420px'; canvas.style.height='420px'; canvas.style.display='block'; canvas.style.background='transparent';
      // Allow interacting with the model area — enable pointer events on the canvas and show grab cursor
      canvas.style.pointerEvents = 'auto';
      canvas.style.cursor = 'grab';
      modelContainer.appendChild(canvas);

      // Simple Ctrl/Meta + left-click drag on the canvas to move the model container
      (function(){
        const canvasDrag = { active: false, pid: null, startX: 0, startY: 0, origLeft: 0, origTop: 0 };

        function onCanvasPointerDown(e){
          // require Ctrl or Meta (Cmd) modifier and left button
          if(!(e.ctrlKey || e.metaKey)) return;
          if(e.button && e.button !== 0) return;
          e.preventDefault();
          const cs = getComputedStyle(modelContainer);
          canvasDrag.origLeft = parseInt(cs.left || 0, 10);
          canvasDrag.origTop = parseInt(cs.top || 0, 10);
          canvasDrag.startX = e.clientX;
          canvasDrag.startY = e.clientY;
          canvasDrag.active = true;
          canvasDrag.pid = e.pointerId;
          try{ canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId); }catch(_){ }
          try{ if(controls) controls.enabled = false; }catch(_){ }
          canvas.style.cursor = 'grabbing';
        }

        function onCanvasPointerMove(e){
          if(!canvasDrag.active || e.pointerId !== canvasDrag.pid) return;
          const dx = e.clientX - canvasDrag.startX;
          const dy = e.clientY - canvasDrag.startY;
          modelContainer.style.left = (canvasDrag.origLeft + dx) + 'px';
          modelContainer.style.top = (canvasDrag.origTop + dy) + 'px';
        }

        function finishCanvasDrag(e){
          if(!canvasDrag.active) return;
          canvasDrag.active = false;
          try{ canvas.releasePointerCapture && canvas.releasePointerCapture(canvasDrag.pid); }catch(_){ }
          canvasDrag.pid = null;
          canvas.style.cursor = 'grab';
          try{ localStorage.setItem('codelumi3d_pos', JSON.stringify({left: modelContainer.style.left, top: modelContainer.style.top})); }catch(_){ }
          try{ if(controls) controls.enabled = true; }catch(_){ }
        }

        canvas.addEventListener('pointerdown', onCanvasPointerDown);
        window.addEventListener('pointermove', onCanvasPointerMove);
        canvas.addEventListener('pointerup', finishCanvasDrag);
        canvas.addEventListener('pointercancel', finishCanvasDrag);
        canvas.addEventListener('lostpointercapture', finishCanvasDrag);
      })();

      // Add a small drag handle so users can move the 3D container while the canvas ignores pointer events
      const dragHandle = document.createElement('div');
      dragHandle.id = 'codelumi3d_handle';
      Object.assign(dragHandle.style, {
        position: 'absolute', top: '6px', right: '6px', width: '28px', height: '28px', borderRadius: '6px',
        background: 'rgba(0,0,0,0.15)', display: 'flex', alignItems: 'center', justifyContent: 'center',
        cursor: 'grab', zIndex: 10, pointerEvents: 'auto'
      });
      dragHandle.title = 'Drag Codelumi';
      modelContainer.style.position = modelContainer.style.position || 'fixed';
      modelContainer.appendChild(dragHandle);

      // drag handle logic: allows dragging the parent container
      (function(){
        let active = false, sx=0, sy=0, ox=0, oy=0;
        function down(e){ if(e.button && e.button!==0) return; active=true; sx = e.clientX; sy = e.clientY; const cs = getComputedStyle(modelContainer); ox = parseInt(cs.left||0,10); oy = parseInt(cs.top||0,10); dragHandle.setPointerCapture && dragHandle.setPointerCapture(e.pointerId); dragHandle.style.cursor='grabbing'; try{ if(controls) controls.enabled = false; }catch(_){ } e.preventDefault(); }
        function move(e){ if(!active) return; const dx = e.clientX - sx; const dy = e.clientY - sy; modelContainer.style.left = (ox + dx) + 'px'; modelContainer.style.top = (oy + dy) + 'px'; }
        function up(e){ if(!active) return; active=false; try{ dragHandle.releasePointerCapture && dragHandle.releasePointerCapture(e.pointerId); }catch(_){} dragHandle.style.cursor='grab'; try{ localStorage.setItem('codelumi3d_pos', JSON.stringify({left:modelContainer.style.left, top:modelContainer.style.top})); }catch(_){ } try{ if(controls) controls.enabled = true; }catch(_){ } }
        dragHandle.addEventListener('pointerdown', down);
        window.addEventListener('pointermove', move);
        window.addEventListener('pointerup', up);
      })();

      // Note: container dragging is handled only via the drag handle above.

      const renderer = new THREE.WebGLRenderer({canvas: canvas, alpha:true}); renderer.setSize(768,768); renderer.setClearColor(0x000000, 0);
      const scene = new THREE.Scene(); const cam = new THREE.PerspectiveCamera(45,1,0.1,100); cam.position.set(0,0,8);
      scene.add(new THREE.AmbientLight(0xffffff,0.95));
      const dir = new THREE.DirectionalLight(0xffffff,1.0); dir.position.set(5,10,7); scene.add(dir);

      // OrbitControls for looking around the model
      let controls = null;
      try{
        controls = new OrbitControls(cam, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.12;
        controls.enablePan = false;
        controls.minDistance = 1.5;
        controls.maxDistance = 30;
      }catch(_){ controls = null; }

      const loader = new GLTFLoader();
      let modelRoot = null; let fallbackCube = null; let mixer = null; let gltfAnimations = null; let currentClip = null;
      let rotateEnabled = false;
      const clock = new THREE.Clock();
      let currentMode = 'idle'; let walkPhase = 0; let rotR = 0;
      let waveNode = null; let waveStart = 0; let waveTargetBone = null;
      let boneMap = null;
      // permanent glitch effect (no UI toggle) — subtle wireframe + jitter
      const glitchConfig = { intervalMin: 4.0, intervalMax: 10.0, durationMin: 0.12, durationMax: 0.45, strength: 0.08 };
      let glitchState = { nextAt: null, activeUntil: 0, active: false };
      const _glitchBackup = new Map();
      function _randBetween(a,b){ return a + Math.random()*(b-a); }
      function _lerp(a,b,t){ return a + (b-a) * t; }
      function _scheduleNextGlitch(now){ glitchState.nextAt = now + _randBetween(glitchConfig.intervalMin, glitchConfig.intervalMax); glitchState.active = false; glitchState.activeUntil = 0; }
      function _startGlitch(now){
        glitchState.active = true;
        glitchState.activeUntil = now + _randBetween(glitchConfig.durationMin, glitchConfig.durationMax);
        glitchState.duration = glitchState.activeUntil - now;
        // For a stronger "skin removed" effect, swap each mesh's material to a wireframe-only basic material.
        modelRoot.traverse(o=>{
          if(o.isMesh || o.isSkinnedMesh){
            try{
              if(!_glitchBackup.has(o.uuid)){
                const mat = o.material || null;
                _glitchBackup.set(o.uuid, { originalMaterial: mat || null, pos: o.position.clone(), rot: o.rotation.clone() });
              }
            }catch(_){ }
            try{
              // replace material with a simple white wireframe so "skin" is visually removed
              if(o.material){
                try{
                  if(Array.isArray(o.material)){
                    o.material = o.material.map((oldMat) => {
                      if(o.isSkinnedMesh){
                        return new THREE.MeshStandardMaterial({color:0xffffff, wireframe:true, skinning:true});
                      } else {
                        return new THREE.MeshBasicMaterial({color:0xffffff, wireframe:true});
                      }
                    });
                  } else {
                    if(o.isSkinnedMesh){
                      o.material = new THREE.MeshStandardMaterial({color:0xffffff, wireframe:true, skinning:true});
                    } else {
                      o.material = new THREE.MeshBasicMaterial({color:0xffffff, wireframe:true});
                    }
                  }
                }catch(_){ }
                try{ 
                  if(Array.isArray(o.material)) o.material.forEach(m => { try{ m && (m.needsUpdate = true); }catch(_){ } });
                  else o.material && (o.material.needsUpdate = true);
                }catch(_){ }
              }
            }catch(_){ }
          }
        });
      }
      function _endGlitch(){
        glitchState.active = false; glitchState.activeUntil = 0;
        _glitchBackup.forEach((v, id)=>{
          try{
            const obj = modelRoot.getObjectByProperty && modelRoot.getObjectByProperty('uuid', id);
            if(obj){
              try{
                // restore original material reference if we swapped it
                if(v.originalMaterial !== undefined){
                  obj.material = v.originalMaterial;
                  try{ obj.material && (obj.material.needsUpdate = true); }catch(_){ }
                }
              }catch(_){ }
              if(v.pos) try{ obj.position.copy(v.pos); }catch(_){ }
              if(v.rot) try{ obj.rotation.copy(v.rot); }catch(_){ }
            }
          }catch(_){ }
        });
        // clear backups after restoring
        _glitchBackup.clear();
      }

      // map bones from the GLTF rig so we can apply lightweight procedural overlays
      function mapBones(root){
        try{
          const map = { leftUpperLeg:null, rightUpperLeg:null, leftLowerLeg:null, rightLowerLeg:null, leftUpperArm:null, rightUpperArm:null, leftLowerArm:null, rightLowerArm:null, spine:null, neck:null, head:null, orig: {} };
          // traverse and map by node names
          root.traverse(o=>{ try{ if(!(o && o.name)) return; const n = (o.name||'').toLowerCase(); if(!map.leftUpperLeg && /left.*(thigh|upper.*leg|upperleg|hip|l_?thigh)/.test(n)) map.leftUpperLeg = o; if(!map.rightUpperLeg && /right.*(thigh|upper.*leg|upperleg|hip|r_?thigh)/.test(n)) map.rightUpperLeg = o; if(!map.leftLowerLeg && /left.*(calf|shin|lower.*leg|lowerleg)/.test(n)) map.leftLowerLeg = o; if(!map.rightLowerLeg && /right.*(calf|shin|lower.*leg|lowerleg)/.test(n)) map.rightLowerLeg = o; if(!map.leftUpperArm && /left.*(upperarm|upper_arm|arm|l_?arm)/.test(n)) map.leftUpperArm = o; if(!map.rightUpperArm && /right.*(upperarm|upper_arm|arm|r_?arm)/.test(n)) map.rightUpperArm = o; if(!map.leftLowerArm && /left.*(lowerarm|forearm|lower_arm|l_?forearm)/.test(n)) map.leftLowerArm = o; if(!map.rightLowerArm && /right.*(lowerarm|forearm|lower_arm|r_?forearm)/.test(n)) map.rightLowerArm = o; if(!map.spine && /spine|chest|torso|upperbody/.test(n)) map.spine = o; if(!map.neck && /neck/.test(n)) map.neck = o; if(!map.head && /head/.test(n)) map.head = o; }catch(_){ } });
          // if no bones found via names, try skeleton bones on skinned meshes
          try{
            const skinned = [];
            root.traverse(o=>{ try{ if(o && o.isSkinnedMesh && o.skeleton && o.skeleton.bones && o.skeleton.bones.length) skinned.push(o); }catch(_){ } });
            for(const sm of skinned){
              try{
                for(const b of (sm.skeleton && sm.skeleton.bones) || []){
                  try{
                    const n = (b.name||'').toLowerCase();
                    if(!map.leftUpperLeg && /left.*(thigh|upper.*leg|upperleg|hip|l_?thigh)/.test(n)) map.leftUpperLeg = b;
                    if(!map.rightUpperLeg && /right.*(thigh|upper.*leg|upperleg|hip|r_?thigh)/.test(n)) map.rightUpperLeg = b;
                    if(!map.leftLowerLeg && /left.*(calf|shin|lower.*leg|lowerleg)/.test(n)) map.leftLowerLeg = b;
                    if(!map.rightLowerLeg && /right.*(calf|shin|lower.*leg|lowerleg)/.test(n)) map.rightLowerLeg = b;
                    if(!map.leftUpperArm && /left.*(upperarm|upper_arm|arm|l_?arm)/.test(n)) map.leftUpperArm = b;
                    if(!map.rightUpperArm && /right.*(upperarm|upper_arm|arm|r_?arm)/.test(n)) map.rightUpperArm = b;
                    if(!map.leftLowerArm && /left.*(lowerarm|forearm|lower_arm|l_?forearm)/.test(n)) map.leftLowerArm = b;
                    if(!map.rightLowerArm && /right.*(lowerarm|forearm|lower_arm|r_?forearm)/.test(n)) map.rightLowerArm = b;
                    if(!map.spine && /spine|chest|torso|upperbody/.test(n)) map.spine = b;
                    if(!map.neck && /neck/.test(n)) map.neck = b;
                    if(!map.head && /head/.test(n)) map.head = b;
                  }catch(_){ }
                }
              }catch(_){ }
            }
          }catch(_){ }
          // capture original rotations (also handle bones from skeletons)
          Object.keys(map).forEach(k=>{ if(k==='orig') return; try{ const b = map[k]; if(b && b.rotation){ try{ map.orig[k] = b.rotation.clone(); }catch(_){ map.orig[k] = null; } } }catch(_){ } });
          try{ console.log('mapBones result', { leftUpperArm: map.leftUpperArm && map.leftUpperArm.name, rightUpperArm: map.rightUpperArm && map.rightUpperArm.name }); }catch(_){ }
          return map;
        }catch(e){ return null; }
      }

      function findWaveNode(root){
        try{
          const patterns = ['hand','wrist','right_hand','left_hand','arm','upperarm','forearm'];
          for(const pat of patterns){
            let found = null;
            root.traverse(o=>{ try{ if(found) return; const n = (o.name||'').toLowerCase(); if(n && n.indexOf(pat)!==-1) { found = o; } }catch(_){ } });
            if(found && found !== root) return found;
          }
          // fallback: first bone in any SkinnedMesh skeleton
          let skel = null;
          root.traverse(o=>{ try{ if(!skel && o.isSkinnedMesh && o.skeleton && o.skeleton.bones && o.skeleton.bones.length) skel = o; }catch(_){ } });
          if(skel && skel.skeleton && skel.skeleton.bones && skel.skeleton.bones.length){ return skel.skeleton.bones[0]; }
          // last resort: any bone or skinned mesh (but not the root object)
          let fallback = null; root.traverse(o=>{ try{ if(!fallback && (o.isBone || o.isSkinnedMesh) && o !== root) fallback = o; }catch(_){ } }); return fallback;
        }catch(e){ return null; }
      }

      // procedural settings (modifiable by UI)
      const proceduralSettings = { walkAmp:1.0, walkSpeed:1.0, waveAmp:1.0, breathAmp:1.0, clipBlend:0.9 };
      let autoBreatheEnabled = true;

      function startLoop(){ (function loop(){ const dt = clock.getDelta(); if(mixer) try{ mixer.update(dt); }catch(_){ }
          if(modelRoot){
            // apply rotation speed modifier for certain modes and apply only when rotateEnabled
            let appliedRot = rotR;
            if(currentMode === 'spin') appliedRot = rotR * 6.0;
            if(rotateEnabled){
              try{ modelRoot.rotation.y = appliedRot; }catch(_){ }
            }

            // bone-driven animations when available (with procedural tuning)
              // Use the model's rig and mixer for bone-driven animation — do not override bone rotations.
              // Apply only non-invasive positional transforms and waveNode adjustments so the rig controls poses.
              if(currentMode === 'walk'){
                walkPhase += dt * 4.0;
                modelRoot.position.y = Math.abs(Math.sin(walkPhase)) * 0.05 * (proceduralSettings.walkAmp || 1.0);
                modelRoot.position.x = Math.sin(walkPhase) * 0.3 * (proceduralSettings.walkAmp || 1.0);
                // apply bone swings when available for more natural gait
                if(boneMap){
                  try{
                    const s = Math.sin(walkPhase);
                    const thighAmp = 0.6 * (proceduralSettings.walkAmp || 1.0);
                    const lerpT = 0.22;
                    function lerp(a,b,t){ return a + (b-a) * t; }
                    if(boneMap.leftUpperLeg){ const cur = boneMap.leftUpperLeg.rotation.x || 0; const tgt = (boneMap.orig.leftUpperLeg?boneMap.orig.leftUpperLeg.x:0) + s * thighAmp; boneMap.leftUpperLeg.rotation.x = lerp(cur, tgt, lerpT); }
                    if(boneMap.rightUpperLeg){ const cur = boneMap.rightUpperLeg.rotation.x || 0; const tgt = (boneMap.orig.rightUpperLeg?boneMap.orig.rightUpperLeg.x:0) - s * thighAmp; boneMap.rightUpperLeg.rotation.x = lerp(cur, tgt, lerpT); }
                    if(boneMap.leftLowerLeg){ const cur = boneMap.leftLowerLeg.rotation.x || 0; const tgt = (boneMap.orig.leftLowerLeg?boneMap.orig.leftLowerLeg.x:0) - Math.max(0, s) * thighAmp * 0.6; boneMap.leftLowerLeg.rotation.x = lerp(cur, tgt, lerpT); }
                    if(boneMap.rightLowerLeg){ const cur = boneMap.rightLowerLeg.rotation.x || 0; const tgt = (boneMap.orig.rightLowerLeg?boneMap.orig.rightLowerLeg.x:0) + Math.max(0, -s) * thighAmp * 0.6; boneMap.rightLowerLeg.rotation.x = lerp(cur, tgt, lerpT); }
                    // arms swing opposite to legs (smoothed)
                    if(boneMap.leftUpperArm){ const cur = boneMap.leftUpperArm.rotation.x || 0; const tgt = (boneMap.orig.leftUpperArm?boneMap.orig.leftUpperArm.x:0) - s * 0.4 * (proceduralSettings.walkAmp || 1.0); boneMap.leftUpperArm.rotation.x = lerp(cur, tgt, lerpT); }
                    if(boneMap.rightUpperArm){ const cur = boneMap.rightUpperArm.rotation.x || 0; const tgt = (boneMap.orig.rightUpperArm?boneMap.orig.rightUpperArm.x:0) + s * 0.4 * (proceduralSettings.walkAmp || 1.0); boneMap.rightUpperArm.rotation.x = lerp(cur, tgt, lerpT); }
                  }catch(_){ }
                }
              } else if(currentMode === 'bounce'){
                modelRoot.position.y = Math.abs(Math.sin(rotR * 6.0)) * 0.25;
                modelRoot.position.x = 0;
              } else {
                modelRoot.position.y = Math.sin(rotR*0.6) * 0.02;
                modelRoot.position.x = 0;
              }
              if(currentMode === 'wave'){
                waveStart += dt;
                const amp = (proceduralSettings.waveAmp || 1.0);
                const target = Math.sin(waveStart*8) * 0.9 * amp;
                // prefer an arm bone from boneMap for waving
                let waveTargetBone = null;
                try{ if(boneMap){ waveTargetBone = boneMap.rightUpperArm || boneMap.rightLowerArm || boneMap.leftUpperArm || boneMap.leftLowerArm || null; } }catch(_){ waveTargetBone = null; }
                if(!waveTargetBone) waveTargetBone = (waveNode && waveNode !== modelRoot) ? waveNode : null;
                if(waveTargetBone){ try{ const cur = waveTargetBone.rotation.x || 0; waveTargetBone.rotation.x = _lerp(cur, target, 0.36); }catch(_){ } }
                if(waveStart > 1.6){
                  currentMode = 'idle'; waveStart = 0;
                  if(waveTargetBone){ try{ waveTargetBone.rotation.x = _lerp(waveTargetBone.rotation.x||0, 0, 0.6); }catch(_){ } }
                }
              }
              // breathing overlay — small bob without touching bones
              if(autoBreatheEnabled || currentMode === 'idle' || currentMode === 'clip'){
                const b = Math.sin(rotR*0.6) * (proceduralSettings.breathAmp || 1.0);
                modelRoot.position.y += b * 0.01;
              }
          }
          if(fallbackCube) fallbackCube.rotation.y = rotR;
          // apply rotation only when enabled
          if(modelRoot){
            if(rotateEnabled){
              modelRoot.rotation.y = modelRoot.rotation.y; // keep appliedRot behavior handled above
            }
          }
          // permanent glitch loop: schedule, trigger, and apply short wireframe+jitter bursts
          try{
            const now = clock.getElapsedTime();
            if(glitchState.nextAt === null) _scheduleNextGlitch(now);
            if(!glitchState.active && now >= glitchState.nextAt){ _startGlitch(now); }
            if(glitchState.active){
              const rem = glitchState.activeUntil - now;
              if(rem <= 0){ try{ _endGlitch(); _scheduleNextGlitch(now); }catch(_){ } }
              else {
                // intensity [0..1]
                const intensity = Math.max(0, Math.min(1, 1 - (rem / (glitchState.duration || 0.0001))));
                // apply per-mesh jitter and subtle emissive flicker
                try{
                  _glitchBackup.forEach((v, id)=>{
                    try{
                      const obj = modelRoot.getObjectByProperty && modelRoot.getObjectByProperty('uuid', id);
                      if(!obj) return;
                      const s = glitchConfig.strength * (0.4 + Math.random()*0.6) * (0.5 + intensity*0.9);
                      if(v.pos) obj.position.set(v.pos.x + (Math.random()*2-1)*s, v.pos.y + (Math.random()*2-1)*s, v.pos.z + (Math.random()*2-1)*s);
                      if(v.rot) obj.rotation.set(v.rot.x + (Math.random()*2-1)*s*0.5, v.rot.y + (Math.random()*2-1)*s*0.5, v.rot.z + (Math.random()*2-1)*s*0.5);
                      if(obj.material && obj.material.emissive){ try{ if(typeof obj.material.emissive.offsetHSL === 'function') obj.material.emissive.offsetHSL((Math.random()-0.5)*0.4*intensity, 0.05, 0.03); else obj.material.emissive.r = Math.min(1, (obj.material.emissive.r||0) + 0.02*intensity); }catch(_){ } }
                    }catch(_){ }
                  });
                }catch(_){ }
              }
            }
          }catch(_){ }

          renderer.render(scene,cam);
          // always advance internal phase for procedural overlays
          rotR += 0.01;
          requestAnimationFrame(loop); })(); }

      // public animation API
      window.codelumiAnimations = window.codelumiAnimations || {
        clips: [],
        listClips: ()=>{ return window.codelumiAnimations.clips || []; },
        playClip: (name)=>{
          try{
            if(!mixer || !gltfAnimations) return;
            const clip = (gltfAnimations.find(c=> (c.name||'')===name) || gltfAnimations[0]);
            // stop previous but keep mixer for blending
            try{ mixer.stopAllAction(); }catch(_){ }
            const action = mixer.clipAction(clip);
            action.reset(); action.play(); currentClip = name; currentMode = 'clip';
            // remember current action for live weight control
            window.codelumiAnimations._currentAction = action;
            // apply initial blend weight (use UI value or proceduralSettings)
            const blend = (document.getElementById('codelumiClipBlend') && parseFloat(document.getElementById('codelumiClipBlend').value)) || proceduralSettings.clipBlend || 0.9;
            try{ if(typeof action.setEffectiveWeight === 'function') action.setEffectiveWeight(blend); else action.weight = blend; }catch(_){ try{ action.weight = blend; }catch(_){} }
          }catch(e){ console.warn('playClip failed', e); }
        },
        setMode: (m)=>{ try{ const prev = currentMode; currentMode = m; try{ console.log('codelumi:setMode', m, { mixer: !!mixer, gltfAnimationsCount: (gltfAnimations? gltfAnimations.length:0), modelRootPresent: !!modelRoot, fallbackCubePresent: !!fallbackCube, currentMode }); }catch(_){ }
          // entering spin should ensure visible rotation regardless of previous rotate setting
          if(m === 'spin') try{ rotateEnabled = true; if(codelumiToggleRotate) codelumiToggleRotate.textContent = 'Stop Rotate'; }catch(_){ }
          // idle should reset procedural transforms and restore original bone rotations
          if(m === 'idle'){
            try{ // reset positions
              if(modelRoot){ modelRoot.position.set(0,0,0); try{ modelRoot.rotation.set(0,0,0); }catch(_){ } }
              // if we are coming from spin, stop visible rotation
                if(prev === 'spin'){
                rotateEnabled = false;
                try{ if(codelumiToggleRotate) codelumiToggleRotate.textContent = 'Resume Rotate'; }catch(_){ }
                try{ if(modelRoot) modelRoot.rotation.set(0,0,0); }catch(_){ }
              }
              if(boneMap){ Object.keys(boneMap).forEach(k=>{ if(k==='orig') return; try{ const b = boneMap[k]; const o = boneMap.orig[k]; if(b && o && b.rotation){ b.rotation.copy(o); } }catch(_){ } }); }
              // clear wave target
              waveTargetBone = null;
            }catch(_){ }
          }
          // when entering wave, pick a target bone (prefer right arm) and log it for debugging
          if(m === 'wave'){
            try{
              waveTargetBone = null;
              if(boneMap){ waveTargetBone = boneMap.rightUpperArm || boneMap.rightLowerArm || boneMap.leftUpperArm || boneMap.leftLowerArm || null; }
              if(!waveTargetBone) waveTargetBone = (waveNode && waveNode !== modelRoot) ? waveNode : null;
              try{ console.log('codelumi:waveTarget', { waveTargetBoneName: waveTargetBone && waveTargetBone.name ? waveTargetBone.name : null, hasBoneMap: !!boneMap }); }catch(_){ }
            }catch(_){ }
          }
          if(m !== 'clip' && mixer) { mixer.stopAllAction(); currentClip = null; }
          // expose a getter for external callers that may attach early
          try{ window.codelumiAnimations.getMode = function(){ try{ return currentMode; }catch(_){ return null; } }; }catch(_){ }
        }catch(e){ console.warn('setMode error', e); } },
        wave: ()=>{ currentMode = 'wave'; },
        getMode: ()=>{ try{ return currentMode; }catch(_){ return null; } }
      };

      // allow external UI to toggle rotation state
      try{
        window.codelumiAnimations.setRotateEnabled = function(enabled){
          rotateEnabled = !!enabled;
          try{
            const btn = document.getElementById('lumiToggleRotate') || document.getElementById('codelumiToggleRotate');
            if(btn) btn.textContent = rotateEnabled ? 'Stop Rotate' : 'Resume Rotate';
          }catch(_){ }
        };
      }catch(_){ }

      // apply saved spin-on-open setting inside the 3D module
      try{
        const s = (window.loadSettings && typeof window.loadSettings === 'function') ? window.loadSettings() : null;
        if(s && s.spinOnOpen){ window.codelumiAnimations.setRotateEnabled(true); }
      }catch(_){ }

      // prefer an explicitly saved workspace model filename when present
      const initialModelFilename = (function(){ try{ return localStorage.getItem('lumi_model_filename') || 'Lumi.glb'; }catch(e){ return 'Lumi.glb'; } })();
      loader.load('assets/models/' + initialModelFilename, (gltf)=>{
        try{
          modelRoot = gltf.scene || (gltf.scenes && gltf.scenes[0]);
          if(!modelRoot) throw new Error('no scene');
          modelRoot.scale.set(1.6,1.6,1.6);
          modelRoot.rotation.x = 0;
          scene.add(modelRoot);
          try{
            const box = new THREE.Box3().setFromObject(modelRoot);
            const center = new THREE.Vector3(); box.getCenter(center);
            modelRoot.position.sub(center);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = cam.fov * (Math.PI/180);
            const cameraZ = Math.abs(maxDim / 2 / Math.tan(fov/2)) * 1.2;
            const yOffset = Math.max(0.15, size.y * 0.08);
            cam.position.set(0, yOffset + cameraZ * 0.05, cameraZ);
            cam.lookAt(0, Math.max(0, size.y * 0.02), 0);
            cam.updateProjectionMatrix();
            if(controls) try{ controls.target.set(0, Math.max(0, size.y * 0.02), 0); controls.update(); }catch(_){ }
          }catch(_){ }

          // setup animations if present
          if(gltf.animations && gltf.animations.length){
            try{ mixer = new THREE.AnimationMixer(modelRoot); mixer.clipAction(gltf.animations[0]).play(); }catch(e){ console.warn('mixer setup failed', e); }
            // build bone map for procedural overlay
            try{ boneMap = mapBones(modelRoot); try{ populateBoneSelect && populateBoneSelect(); }catch(_){ } }catch(_){ boneMap = null; }
            try{
              gltfAnimations = gltf.animations || null;
              const names = (gltfAnimations||[]).map((c,i)=> (c && c.name && c.name.length) ? c.name : ('clip' + i));
              window.codelumiAnimations = window.codelumiAnimations || {};
              window.codelumiAnimations.clips = names;
              // populate UI select if present
              try{ const sel = document.getElementById('codelumiClipSelect'); if(sel){ sel.innerHTML = '<option value="">(select)</option>'; names.forEach(n=>{ const o = document.createElement('option'); o.value = n; o.textContent = n; sel.appendChild(o); }); } }catch(e){}
            }catch(e){ console.warn('populate clips failed', e); }
          }
          waveNode = findWaveNode(modelRoot);
          startLoop();
          try{ console.log('Codelumi GLB loaded', { mixer: !!mixer, gltfAnimationsCount: (gltfAnimations? gltfAnimations.length:0), modelRootPresent: !!modelRoot, waveNodePresent: !!waveNode }); }catch(_){ console.log('Codelumi GLB loaded'); }
        }catch(e){ console.warn('GLB load parse error', e); }
      }, undefined, (err)=>{
        console.warn('GLTF load failed', err);
        // visible renderer warning about missing model path
        try{
          const expectedUrl = (function(){ try{ return new URL('assets/models/' + initialModelFilename, location.href).href; }catch(e){ return 'assets/models/' + initialModelFilename; } })();
          // create or update warning element
          let warn = document.getElementById('codelumiModelWarning');
          if(!warn){
            warn = document.createElement('div');
            warn.id = 'codelumiModelWarning';
            warn.style.position = 'absolute';
            warn.style.right = '12px';
            warn.style.top = '12px';
            warn.style.zIndex = '99999';
            warn.style.background = 'rgba(255,230,230,0.98)';
            warn.style.color = '#2b2b2b';
            warn.style.padding = '10px 12px';
            warn.style.border = '1px solid rgba(200,80,80,0.9)';
            warn.style.borderRadius = '6px';
            warn.style.boxShadow = '0 6px 20px rgba(0,0,0,0.2)';
            warn.style.fontSize = '13px';
            warn.style.maxWidth = '420px';
            warn.style.wordBreak = 'break-word';
            document.body.appendChild(warn);
          }
          warn.innerHTML = '<strong>Model not found</strong><div style="margin-top:6px;">Expected: <code style="font-size:12px;color:#111">' + expectedUrl + '</code></div><div style="margin-top:8px;color:#444;font-size:12px">Using fallback cube. Place your GLB at this path and rebuild or copy into <code>dist/assets/models/</code>.</div><div style="margin-top:8px;text-align:right"><button id="codelumiWarnClose" style="background:#e86b6b;border:none;color:#fff;padding:6px 8px;border-radius:4px;cursor:pointer">Dismiss</button></div>';
          const btn = document.getElementById('codelumiWarnClose');
          if(btn) btn.onclick = ()=>{ try{ warn.parentNode && warn.parentNode.removeChild(warn); }catch(_){ } };
        }catch(_){ }

        // fallback visual
        const geom = new THREE.BoxGeometry(2.0,2.0,2.0); const mat = new THREE.MeshStandardMaterial({color:0xff7ab6, metalness:0.2, roughness:0.6}); fallbackCube = new THREE.Mesh(geom, mat); scene.add(fallbackCube); startLoop();
        try{ console.log('codelumi:GLTF load failed - using fallbackCube', { fallbackCubePresent: !!fallbackCube, err, requested: initialModelFilename }); }catch(_){ }
      });
      // expose a loader to load a sample/model by filename from assets/models/
      window.codelumiAdmin = window.codelumiAdmin || {};
      window.codelumiAdmin.loadSample = function(filename){
        try{
          const path = 'assets/models/' + filename;
          // remove previous model
          try{ if(modelRoot){ scene.remove(modelRoot); modelRoot.traverse && modelRoot.traverse(o=>{ if(o.geometry) o.geometry.dispose && o.geometry.dispose(); if(o.material) { if(Array.isArray(o.material)) o.material.forEach(m=>m.dispose && m.dispose()); else o.material.dispose && o.material.dispose(); } }); } }catch(_){ }
          mixer = null; gltfAnimations = null; currentClip = null; waveNode = null; modelRoot = null;
          // load new
          loader.load(path, (gltf)=>{
            try{
              modelRoot = gltf.scene || (gltf.scenes && gltf.scenes[0]); if(!modelRoot) throw new Error('no scene');
              modelRoot.scale.set(1.6,1.6,1.6); modelRoot.rotation.x = 0; scene.add(modelRoot);
              try{ const box = new THREE.Box3().setFromObject(modelRoot); const center = new THREE.Vector3(); box.getCenter(center); modelRoot.position.sub(center); }catch(_){ }
              if(gltf.animations && gltf.animations.length){ try{ mixer = new THREE.AnimationMixer(modelRoot); gltf.animations.forEach((c,i)=>{}); gltfAnimations = gltf.animations; const names = gltfAnimations.map((c,i)=>(c.name&&c.name.length)?c.name:('clip'+i)); window.codelumiAnimations = window.codelumiAnimations || {}; window.codelumiAnimations.clips = names; try{ const sel = document.getElementById('codelumiClipSelect'); if(sel){ sel.innerHTML = '<option value="">(select)</option>'; names.forEach(n=>{ const o = document.createElement('option'); o.value = n; o.textContent = n; sel.appendChild(o); }); } }catch(e){} }catch(e){ console.warn(e); } }
              boneMap = mapBones(modelRoot);
              try{ populateBoneSelect && populateBoneSelect(); }catch(_){}
              waveNode = findWaveNode(modelRoot); say('Sample loaded: ' + filename,2000,{feedback:false});
            }catch(e){ console.warn('sample parse failed', e); say('Sample load failed'); }
          }, undefined, (err)=>{ console.warn('sample load failed', err); say('Sample not found: ' + filename,2000,{feedback:false}); });
        }catch(e){ console.warn('loadSample failed', e); }
      };
    }catch(e){ console.warn('3D init failed', e); }
  })();
  </script>
  <script>
  // Make elements draggable by pointer (mouse/touch)
  (function(){
    function makeDraggable(el, handle){
      if(!el) return;
      const target = handle || el;
      target.style.touchAction = 'none';
      target.style.cursor = 'grab';

      let dragging = false;
      let startX=0, startY=0, origX=0, origY=0;

      function onPointerDown(e){
        if(e.button && e.button !== 0) return;
        // If the pointerdown originated on an interactive control, don't start dragging
        try{
          const t = e.target;
          if(t && (t.closest && t.closest('input,textarea,button,select,a,label,[contenteditable]'))) return;
        }catch(_){ }
        const rect = el.getBoundingClientRect();
        // ensure element has left/top so we can move it; clear right/bottom anchoring
        const cs = getComputedStyle(el);
        if(cs.position === 'fixed' || cs.position === 'absolute' || cs.left === 'auto' || (cs.left === '0px' && (cs.right && cs.right !== 'auto'))){
          el.style.left = rect.left + 'px';
          el.style.top = rect.top + 'px';
          el.style.right = 'auto';
          el.style.bottom = 'auto';
        }
        startX = e.clientX;
        startY = e.clientY;
        origX = parseInt(getComputedStyle(el).left || 0, 10);
        origY = parseInt(getComputedStyle(el).top || 0, 10);
        dragging = true;
        target.setPointerCapture && target.setPointerCapture(e.pointerId);
        target.style.cursor = 'grabbing';
      }

      function onPointerMove(e){
        if(!dragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        el.style.left = (origX + dx) + 'px';
        el.style.top = (origY + dy) + 'px';
      }

      function onPointerUp(e){
        if(!dragging) return;
        dragging = false;
        try{ target.releasePointerCapture && target.releasePointerCapture(e.pointerId); }catch(_){}
        target.style.cursor = 'grab';
        try{ if(el && el.id){ localStorage.setItem(el.id + '_pos', JSON.stringify({left:el.style.left, top:el.style.top})); } }catch(_){ }
      }

      target.addEventListener('pointerdown', onPointerDown);
      window.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
    }

    // Attach to avatar, settings, panels and standalone model container and restore saved positions
    document.addEventListener('DOMContentLoaded', ()=>{
      const lumi = document.getElementById('lumi');
      const codelumi3d = document.getElementById('codelumi3d');
      const settingsPanel = document.getElementById('settingsPanel');
      const codePanel = document.getElementById('codePanel');
      const bubbleEl = document.getElementById('bubble');
      const historyPanel = document.getElementById('historyPanel');
      const memoryPanel = document.getElementById('memoryPanel');
      // restore positions if saved
      try{
        const kpos = localStorage.getItem('lumi_pos');
        if(kpos && lumi){ const p = JSON.parse(kpos); if(p.left) lumi.style.left = p.left; if(p.top) lumi.style.top = p.top; }
      }catch(_){ }
      try{
        const mpos = localStorage.getItem('codelumi3d_pos');
        if(mpos && codelumi3d){ const p = JSON.parse(mpos); if(p.left) codelumi3d.style.left = p.left; if(p.top) codelumi3d.style.top = p.top; }
      }catch(_){ }
      try{
        const spos = localStorage.getItem('settingsPanel_pos');
        if(spos && settingsPanel){ const p = JSON.parse(spos); if(p.left) settingsPanel.style.left = p.left; if(p.top) settingsPanel.style.top = p.top; settingsPanel.style.position='fixed'; }
      }catch(_){ }
      try{
        const ppanel = document.getElementById('personalityPanel');
        const ppos = localStorage.getItem('personalityPanel_pos');
        if(ppos && ppanel){ const q = JSON.parse(ppos); if(q.left) ppanel.style.left = q.left; if(q.top) ppanel.style.top = q.top; ppanel.style.position='fixed'; }
      }catch(_){ }
      
      try{
        const cpos = localStorage.getItem('codePanel_pos');
        if(cpos && codePanel){ const p = JSON.parse(cpos); if(p.left) codePanel.style.left = p.left; if(p.top) codePanel.style.top = p.top; codePanel.style.position='fixed'; }
      }catch(_){ }
      try{
        localStorage.removeItem('bubble_pos'); // Reset bubble position to CSS defaults
      }catch(_){ }

      makeDraggable(lumi);
      makeDraggable(codelumi3d);
      makeDraggable(settingsPanel);
      try{ const ppanel = document.getElementById('personalityPanel'); if(ppanel) makeDraggable(ppanel); }catch(_){ }
      makeDraggable(codePanel);
      makeDraggable(bubbleEl);
    });
  })();
  </script>
  <script type="module">
    // Load React components as proper Vite modules (avoids inline import corruption)
    (async () => {
      try {
        const mod = await import('./src/components/AutoCodeBox.tsx');
        if (mod && mod.default) window.__AutoCodeBox = mod.default;
      } catch (_) { /* optional */ }
      try {
        const mod = await import('./src/components/CodeEditorEnhanced.tsx');
        if (mod && mod.default) window.__CodeEditorEnhanced = mod.default;
      } catch (_) { /* optional */ }
      // SecurityCurator: NOT loaded here — the inline DOM curator in index.html
      // is the full-featured version (draggable, path redaction, archives, etc.)
    })();
  </script>
</body>
</html>
